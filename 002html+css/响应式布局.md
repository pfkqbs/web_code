课程简介



## 1. 本课程的由来

这些年，随着IT和互联网产业的逐渐成熟，对于开发者的技术要求越来越高，求职竞争也不断加剧。

我们随便打开一个招聘软件就可以看到`Web前端`有相当一部分岗位不仅仅要求你只会做 PC 端，而且还要你会移动端、微信小程序、至少一门后台语言、RESTful、GraphQL、webpack、websocket等各种各样五花八门的技术。也难怪经常有人调侃自己学不动了…

但无论这些技术再怎么百花齐放，前端终归还是要写页面的。毕竟在当年还没有前端这个岗位的时候，就是程序员写完后台再用 jQuery 写一下页面，只不过后来技术越来越多，人的精力终究是有限的，所以单独又细分出来了一个领域。

不过没想到的是这个领域在近些年发展的竟如此繁华。平地高楼万丈起，就算再繁华的大厦也是要先从打地基开始的，页面上那些看得见摸得着的画面就是前端的地基！

于是就有了这门《移动端布局》，其实一开始是并没有这门课的，有的只是《CSS布局》这门课。但在为课程制作大纲时，我为了尽可能的全面，写了一份内容超长的大纲。慕课网的内容负责人觉得内容实在是太多了，可能会导致大家看了目录就直接从入门到放弃了。

在砍掉一部分内容后再把课程进行拆分，于是乎《移动端布局》诞生啦！
![图片描述](http://img.mukewang.com/wiki/5f6c50e00959d78402880592.jpg)
由于移动互联网时代的到来，手机端的使用频率居然比电脑还要高。



## 2. 前端的基础

不管这个网站的页面背后有着多么复杂的交互逻辑、多庞大的用户量、多么海量的数据、多么高的并发…
首先你得有个页面吧！不能让用户一访问网站直接给人家看数据库吧！

> 有人的地方就有江湖 有页面的地方就有布局

布局可不仅仅只是把数据整齐的罗列在页面上这么简单，一个合适的布局可以令用户的操作非常顺畅。同时在不同的场景下也应选择不同的布局，如果选错布局的话很可能会导致用户对页面的操作不丝滑，哪怕最初呈现出来的数据都是一样的。
![图片描述](http://img.mukewang.com/wiki/5f6c548408973d5005000420.jpg)



## 3. 前端的优势

网页有一个最优秀的特点就是它的跨平台性，一个前端程序员写出的页面，既可以运行在 Windows 的浏览器上、也可以运行在 MacOS 的浏览器上、还可以运行在 IOS 和安卓浏览器上。正是由于网页所具备的优异跨平台性扩展出了套壳网页的这种形式，比如看起来只是个 apk 的安卓程序，点击也能安装到手机中，但实际上里面的内容都是网页…
![图片描述](http://img.mukewang.com/wiki/5f6c57290854b0c705000305.jpg)
还有现在红极一时的小程序，其实在很早以前小程序就已经火起来了，但这次疫情真的是把小程序彻底推向了一个巅峰：去商场要扫小程序二维码、坐高铁要扫小程序二维码、去麦当劳要用小程序点餐、去景点参观要用小程序预约、去看电影要用小程序订票…

那么小程序其实是和前端技术是分不开的，虽然腾讯觉得自己搞的东西不能叫HTML、CSS，取而代之的是 WX(*微信*)ML、WX(*微信*)SS… 但其实还是换汤不换药，语法什么的都基本一致，好多东西甚至连名称都没改。

而且我们现在做小程序也有那种多端小程序框架：uni-app、mpvue、taro等…
这里用的都是 CSS 而不是 微信SS 。

所以学会了移动端布局，不仅仅可以把学到的知识运用到移动端的网页上、还可以用到 React Native、小程序、快应用、Weex等这些前端演变出来的技术上。



## 4. 本课程的设计思路

首先我们会用最被广泛使用同时还特别简单的一种布局(*居中布局*)来作为开篇第一个布局进行切入，由浅入深，用各种各样五花八门的 CSS 技术来实现同一种布局，以丰富大家的视角。

同时我们的布局也是各式各样，基本把最常见的几种布局方式都罗列了出来：

- 居中布局
- 单列布局
- 双列布局
- 吕形布局
- 上下栏布局
- 九宫格布局
- 响应式布局

尤其是最后这两种布局，用肉眼看可能没啥，但实际用代码实现还是较为复杂的，不过也有简便方式，在每门课(*除了单列布局*)的第一小节，我们都会使用一个非常利于我们学习和记忆的 CSS 库：[chinese-layout](https://www.yuque.com/vue-sharp/oco0rf/ded6m5) ，这个 CSS 库的神奇之处就在于可以使用一部分中文关键字，原理其实就是 [CSS变量](https://juejin.im/post/6856668819344392206#heading-1) ，用它很轻松的就可以实现出一个布局。

用它我们就可以两行代码实现一个布局，当然，不仅要学会库的使用，还要学会经典 CSS 技术的运用：

- 左浮动
- 自动外边距
- 绝对定位
- 固定定位

这些技术兼容性都非常的好，但在下一章我们就会讲一下移动端浏览器的兼容性为什么比 PC 端的好一些，在这种广泛支持 CSS3 的大背景下，我们还要学习新技术的运用：

- 多列属性
- 行内块元素
- 表格布局
- 弹性布局
- 网格布局
- 媒体查询



## 5. 前置知识

本门课程虽然为初学者课程，但并不代表你已经工作了这门课就不适合你了。假如屏幕前的你在工作过程中写的页面多数是显示在 PC 端的，但对移动端了解较少，这门课还是值得去深入学习的。

另一方面即使你的工作过程中也写了很多移动端的网站，你也可以来看一看你有没有全部掌握课程中的各种布局的所有实现方式。因为即便是同一种布局，也会有各种各样的不同方式可以实现，加深一下印象，下次跳槽面试的时候就不怕面试官的各种刁难了。

同时，如果屏幕前的你什么也不会，只知道想入门前端需要学 HTML + CSS + JS ，那么这门课大概率你是看不懂的，多少还是需要对 HTML 和 CSS 有一定的了解才行。



## 6. 结语

小白同学不要被我上面那段话吓到哈，本门课程从技术角度来讲并不难，难的只是思路较多，从这个思路出发可以实现这种布局、换个思路依然可以实现这种布局，有利于开阔大家的视野和思路。

而且像我说的，很少有前端只做 PC 页面而不碰移动端的了，因为移动端互联网本身就已经赶超 PC 上网了，同时又不仅仅是浏览网页这么简单，就想想你扫的那堆健康码小程序是不是前端做出来的吧。

既然《移动端布局》的用途这么广泛，那还等什么呢？赶紧上车，一起去开起布局世界的大门吧！

# 移动端的迭代速度



## 1. 前言

由于移动端并不像电脑屏幕那么大，而且长宽比也有很大的区别，所以造就了移动端布局与 PC 端布局有着很大的不同，本章我们就来聊一聊移动端布局通常都有什么特点。



## 2. PC 端迭代速度

移动端大部分指的是手机，大家目前的生活基本已经离不开手机了。

但是手机的迭代速度可不同于电脑，相信来到慕课网的小伙伴们都是想学习编程的，想学习编程的话基本上都得有一台电脑。

无论是笔记本电脑还是台式电脑，大家可以发现其寿命要远高于手机。通常情况下只要你不是处于一种极端环境下使用电脑的话一般都可以用很多年。
![图片描述](http://img.mukewang.com/wiki/5ee1acb509d49db203440440.jpg)
这也就是为什么做 PC 网站的程序员有一部分还要去兼容IE的原因， WindowsXP 至今还有人在使用，已经停止维护了的 win7 目前市场份额仍然高居 25% 左右。

只要保养得当台式机通常都可以用七年以上，七年之痒不再是难题，笔记本的话也至少可以使用 3 年。



## 3. 移动端迭代速度

但是手机就不一样了，想象一下十年前的手机什么样？那时候最火的莫过于 iPhone4了吧，甚至有人愿意为了一部 iPhone4 不惜卖肾求荣。

而如今谁还会用 iPhone4，安卓和 IOS 版本更新迭代速度也是飞快，即使是3年前火的不行的全面屏手机，现如今不是人手一部？

一方面，大部分人玩手机的时间都远超他们玩电脑的时间，甚至相当一部分人没有电脑，只有手机。

这就导致了手机的磨损程度很高，很多人的手机基本都不关机，手机从买回来就一直处于待机状态，所以就更容易坏掉换新的。

另一方面，手机的价格远低于电脑。再加上每年电商各种购物节的刺激下，许多人年年都换一部新手机：
![图片描述](http://img.mukewang.com/wiki/5ee1acdc0933873710360577.jpg)
如图所示，在生活中处处都存在着换手机的诱因，低版本浏览器过不了两年就会消失在茫茫的市场中。



## 4. 对比

可能有人会说手机价格没有远低于电脑啊，我口袋里 iPhone 是花了八千块买的呢，而我桌子上的电脑只花了五千块。

只能说，要按同水平的去比较这个价位，苹果手机就应该和苹果电脑去比，苹果手机花了八千，而苹果电脑花上个一万五还只能买个一般的，还得是笔记本，台式更贵。
![图片描述](http://img.mukewang.com/wiki/5ee1acf10971adc308460600.jpg)
所以这就导致了几年前的安卓系统或者 IOS 系统早就被淘汰了，不像 windows 系统那么坚挺。而伴随着安卓 IOS 系统的那些低版本浏览器也就一并被抛弃在历史的长河之中了，这对于我们开发者而言是一件非常有利的事情，我们可以不必像在开发PC端网站时考虑那么多的兼容性问题，可以大量使用各种 JS 新特性和 CSS 新特性，PC 端还有没完全普及的 Flex(*超级好用*)，在移动端基本上家家户户都在使用。

甚至在 PC 端没什么项目敢用的 vw、vh 属性，在移动端也已经开始陆陆续续有项目在用了。



## 5. 小节

综上，得益于手机的更新迭代速度较快，移动端在兼容性问题总是处于领先状态。

# 移动端的屏幕长宽比



## 1. 前言

长宽比通常也决定了使用布局的方式，电脑的屏幕通常都是横着的，也就是宽大于高，所以在 PC 端网站上经常可以看到两列布局、三列布局等多列布局。

虽然 PC 端的宽很大，可以容纳更多的列，但是高相对来说就较窄了，所以通常上下都是没有遮挡的。

即使有 header 和 footer 也都不是固定的，只要用户滑动鼠标滚轮，header 或 footer 就会随着页面的滚动而超出屏幕之外变得不可见。



## 2. 移动端的横竖屏

而移动端的宽高比刚好相反，手机通常都是竖着的，只有在看电影电视剧或者玩游戏的时候才会横过来，甚至有许多用户直接锁定了竖屏，即使横过来手机也不会发生任何变化。

这就导致了移动端与 PC 端的布局有很大的不同，移动端是宽太窄了，通常只能容纳一个列(*横行竖列*)，但是高却很长，尤其是现在的全面屏，让人感觉屏幕超级长，这时候就可以在行(*横行竖列*)上动手脚了，比较常见的一种布局是上面一行和下面一行固定在屏幕的 header 和 footer，它们并不会随着屏幕的滚动而移动，类似于这样：
![图片描述](http://img.mukewang.com/wiki/5f0d527f095c549503220664.jpg)
微信几乎是大家最熟悉的软件了，没有了它就相当于没有了社交，在这样一款用户及其庞大的软件上就运用了移动端最经典的布局。
滑动好友列表最上面的灰色那栏并不会移动：
![图片描述](http://img.mukewang.com/wiki/5ee1af21099425bc03900042.jpg)
同理，下面的那栏控制着微信的会话、通讯录、朋友圈以及设置等重要功能，它也不会被移动：
![图片描述](http://img.mukewang.com/wiki/5ee1af3009660ecd03910048.jpg)
将此种布局稍微抽象一下就能得出这样的一张图：
![图片描述](http://img.mukewang.com/wiki/5ee1aee5094de96c03780678.jpg)
最上面的那行通常被称为 header，最下面的通常被称为 footer，很好理解，头和脚嘛！



## 3. 小结

那么接下来的章节我们将会带领大家认识一下除了微信这种布局方式，移动端还有哪些常见的布局。

本节主要介绍了移动端的横纵比例：

- PC端设备的宽高比例
- PC端比例决定的布局方式
- 移动端设备的宽高比例
- 移动端比例决定的布局方式

![图片描述](http://img.mukewang.com/wiki/5f4736c4099a8cc317700470.jpg)

## 居中布局简介



### 1. 前言

接下来我们将带领大家看看移动端常见的居中布局，其实居中布局大家在日常生活中基本都见过，只是当时没怎么留意罢了。

没给用户留下深刻印象的布局反而是好布局，因为用户的注意力都在内容上了，证明此时的布局令用户操作顺畅。

而给用户留下印象的布局一般就不太好了（一些与众不同的炫酷布局除外）：

> 这个按钮怎么放这了，我都误碰好几次了；关闭按钮在哪呢？怎么关啊这个；这个商品的简介在哪呢？应该点哪购买啊？这个布局怎么这么乱看的我都晕了，哎算了算了，以后不来这个网站了……

不同的布局用来对应不同的场景，用对场景的话会令用户的操作比较舒服顺畅，但用错场景的话用户可能会有些懵，不利于引导用户按自己想要的方式去操作。



### 2. 效果展示

![img](http://img.mukewang.com/wiki/5ee1b27e09efe32104920734.jpg)这种布局是主内容处于页面的正中央位置，常见于登录、注册、提示用户、或点击头像查看大图等场景：

![img](http://img.mukewang.com/wiki/5ee1b294097a271204320733.jpg)除了上图那样为了美观而添加的白色透明遮罩，还有一种是为了突出主题，添加的是一层灰色的透明遮罩：

![img](http://img.mukewang.com/wiki/5ee1b2ac0927444103980800.jpg)图片来源 微博

这么做的目的除了突出主题之外，还有一个比较重要的点就是可以令用户感觉到自己并没有离开当前页面，只不过是在当前页面中出现了一个小框而已，这样可以有效减少用户的陌生感。

![img](http://img.mukewang.com/wiki/5ee1b2c709e1a05504050849.jpg)图片来源 慕课网[@imooc](https://www.imooc.com/)不仅如此，居中布局还能够有效引导用户进行自己希望用户所进行的操作，用强烈的对比感去引导用户：

![img](http://img.mukewang.com/wiki/5ee1b2e709acfc3d03990672.jpg)图片来源 慕课网[@imooc](https://www.imooc.com/)



### 3. 实现手段

一方面我们可以利用现有的CSS中文库：[chinese-layout](https://www.yuque.com/vue-sharp/oco0rf/ded6m5) 来快速实现居中布局：

- [中文布局 CSS 库](https://www.imooc.com/wiki/mobilelayout/chinesecenter.html)

> 这种方式不仅利于我们的学习，更加有助于我们的记忆。

然后也会带领大家如何在不依赖于任何外界条件的情况下纯手工实现居中布局：

- [绝对定位法](https://www.imooc.com/wiki/mobilelayout/abs.html)
- [绝对定位 + 负边距](https://www.imooc.com/wiki/mobilelayout/absmargin.html)
- [绝对定位 + 平移](https://www.imooc.com/wiki/mobilelayout/abstrans.html)
- [网格布局](https://www.imooc.com/wiki/mobilelayout/grid.html)
- [弹性布局](https://www.imooc.com/wiki/mobilelayout/flexbox.html)
- [表格布局](https://www.imooc.com/wiki/mobilelayout/table.html)



### 4. 小结

![图片描述](http://img.mukewang.com/wiki/5f87ee1109dbef3d10560474.jpg)
本小节我们为大家展示了居中布局的样子以及它经常出现的一些场景，可以看到各大网站几乎都会用到居中布局，而且看起来也似乎有种似曾相识的感觉。

居中布局在移动端拥有十分广泛的应用，不过大多起的是一种引导或提示作用。
下一小节我们将讲解一下如何用代码去实现居中布局。

## 居中布局简介



### 1. 前言

接下来我们将带领大家看看移动端常见的居中布局，其实居中布局大家在日常生活中基本都见过，只是当时没怎么留意罢了。

没给用户留下深刻印象的布局反而是好布局，因为用户的注意力都在内容上了，证明此时的布局令用户操作顺畅。

而给用户留下印象的布局一般就不太好了（一些与众不同的炫酷布局除外）：

> 这个按钮怎么放这了，我都误碰好几次了；关闭按钮在哪呢？怎么关啊这个；这个商品的简介在哪呢？应该点哪购买啊？这个布局怎么这么乱看的我都晕了，哎算了算了，以后不来这个网站了……

不同的布局用来对应不同的场景，用对场景的话会令用户的操作比较舒服顺畅，但用错场景的话用户可能会有些懵，不利于引导用户按自己想要的方式去操作。



### 2. 效果展示

![img](http://img.mukewang.com/wiki/5ee1b27e09efe32104920734.jpg)这种布局是主内容处于页面的正中央位置，常见于登录、注册、提示用户、或点击头像查看大图等场景：

![img](http://img.mukewang.com/wiki/5ee1b294097a271204320733.jpg)除了上图那样为了美观而添加的白色透明遮罩，还有一种是为了突出主题，添加的是一层灰色的透明遮罩：

![img](http://img.mukewang.com/wiki/5ee1b2ac0927444103980800.jpg)图片来源 微博

这么做的目的除了突出主题之外，还有一个比较重要的点就是可以令用户感觉到自己并没有离开当前页面，只不过是在当前页面中出现了一个小框而已，这样可以有效减少用户的陌生感。

![img](http://img.mukewang.com/wiki/5ee1b2c709e1a05504050849.jpg)图片来源 慕课网[@imooc](https://www.imooc.com/)不仅如此，居中布局还能够有效引导用户进行自己希望用户所进行的操作，用强烈的对比感去引导用户：

![img](http://img.mukewang.com/wiki/5ee1b2e709acfc3d03990672.jpg)图片来源 慕课网[@imooc](https://www.imooc.com/)



### 3. 实现手段

一方面我们可以利用现有的CSS中文库：[chinese-layout](https://www.yuque.com/vue-sharp/oco0rf/ded6m5) 来快速实现居中布局：

- [中文布局 CSS 库](https://www.imooc.com/wiki/mobilelayout/chinesecenter.html)

> 这种方式不仅利于我们的学习，更加有助于我们的记忆。

然后也会带领大家如何在不依赖于任何外界条件的情况下纯手工实现居中布局：

- [绝对定位法](https://www.imooc.com/wiki/mobilelayout/abs.html)
- [绝对定位 + 负边距](https://www.imooc.com/wiki/mobilelayout/absmargin.html)
- [绝对定位 + 平移](https://www.imooc.com/wiki/mobilelayout/abstrans.html)
- [网格布局](https://www.imooc.com/wiki/mobilelayout/grid.html)
- [弹性布局](https://www.imooc.com/wiki/mobilelayout/flexbox.html)
- [表格布局](https://www.imooc.com/wiki/mobilelayout/table.html)



### 4. 小结

![图片描述](http://img.mukewang.com/wiki/5f87ee1109dbef3d10560474.jpg)
本小节我们为大家展示了居中布局的样子以及它经常出现的一些场景，可以看到各大网站几乎都会用到居中布局，而且看起来也似乎有种似曾相识的感觉。

居中布局在移动端拥有十分广泛的应用，不过大多起的是一种引导或提示作用。
下一小节我们将讲解一下如何用代码去实现居中布局。

## 绝对定位实现居中布局



## 1. 前言

居中布局通常分为两种，一种是固定宽高，另一种是非固定宽高。

固定宽高很好理解，非固定宽高通常都是靠里面的内容来撑起盒子的高度，内容时多时少。

这两种方式也造就了不一样的技术实现，我们来看一下。



## 2. 实例代码

假如我们有一个宽度占 70%，高度占 25% 的盒子，我们可以这么写：

实例演示

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 令html和body全屏显示, 并有一个灰色背景 */
    html, body { height: 100%; background: gray; }

    /* 先在父元素上设置相对定位 */
    body { position: relative } 

    .center {
      /* 绝对定位 */
      position: absolute;

      /* 上下左右全部为0 */
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;

      /* 给定宽高 */
      width: 70%;
      height: 25%;

      /* 令外边距自动填充 */
      margin: auto;

      /* 白色背景 */
      background: white;
    }
  </style>
</head>
<body>
  <div class="center"></div>
</body>
</html>

```

[运行案例](http://www.imooc.com/wiki/run/1174.html)点击 "运行案例" 可查看在线运行效果

运行结果：

![图片描述](http://img.mukewang.com/wiki/5ee22a110914f12103750812.jpg)
**代码说明：**

- 如果不给定宽高，盒子将会和父元素一样大，因为绝对定位上下左右都是 0，意为紧贴着父元素的边。
- 给了固定宽高，但没写 **margin** 的话盒子会固定在左上角，因为 top 和 left 的优先级更高。
- 给了 **margin: auto;** 的话，浏览器会自动填充边距，令其居中。
- 此种实现方式优点是兼容性很好，几乎没用到任何 CSS 的新特性，全部都是经典属性。



## 3. 小结

学会了绝对定位来进行居中之后，下一小节我们再来看一下绝对定位怎么和外边距进行搭配。

# 绝对定位+负边距实现居中布局



## 1. 前言

上一小节我们讲了利用绝对定位来进行居中布局。本小节继续讲另外一种方法实现居中布局。

但注意，本小节的"绝对定位+负边距"这种方法不适合绝对定位法那种宽百分之多少、高百分之多少这种相对单位，取而代之的是具体的数值。



## 2. 实例代码

比如，这个例子我们设置居中的盒子宽度为 300px、高度为 200px：

实例演示

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 令html和body全屏显示, 并有一个灰色背景 */
    html, body { height: 100%; background: gray; }

    /* 先在父元素上设置相对定位 */
    body { position: relative }

    .center {
      /* 绝对定位 */
      position: absolute;

      /* 上方和左方为50% */
      top: 50%;
      left: 50%;

      /* 给定宽高 */
      width: 300px;
      height: 200px;

      /* 上外边距为负的给定高度的一半 */
      margin-top: -100px;

      /* 左外边距为负的给定宽度的一半 */
      margin-left: -150px;

      /* 白色背景 */
      background: white;
    }
  </style>
</head>
<body>
  <div class="center"></div>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1175.html)点击 "运行案例" 可查看在线运行效果

运行结果：
![图片描述](http://img.mukewang.com/wiki/5ee22dfd093d91a603750812.jpg)



## 3. 小结

- `top: 50%;` 和 `left: 50%;` 会让盒子的左上角定位到中央位置；
- 所以给上外边距和左外边距一个负值将盒子拉到中央位置；
- margin 的百分比并不是相对于自身，而是相对于父元素的宽度，所以这里不能写成 `-50%`；
- 此种实现方式兼容性也同样十分良好。

# 绝对定位+平移实现居中布局

## 1. 前言

有时中间盒子的内容是要靠后台传过来的数据决定的，如果写死的话，当数据较多时就会发生溢出，数据较少时又会空出一大片，所以我们需要一种更加智能的方式来实现居中布局。

`绝对定位 + 平移` 是 `绝对定位 + 负边距`的改进版，那么具体都改进了哪些方面呢？

负边距的百分比并不是相对于自身，而是相对于父元素，所以只能写具体的像素值，显得不够智能。

而平移相对于自身，只需要无脑写 `-50%` 就可以了。

## 2. 实例代码

来看如何用绝对定位+平移来实现居中布局：

实例演示

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 令html和body全屏显示, 并有一个灰色背景 */
    html, body { height: 100%; background: gray; }

    /* 先在父元素上设置相对定位 */
    body { position: relative }

    .center {
      /* 绝对定位 */
      position: absolute;

      /* 上方和左方为50% */
      top: 50%;
      left: 50%;

      /* 不用给宽高，但是可以给个内边距防止内容与盒子过于贴合 */
      padding: 10px;

      /* 这个50%是相对于自身宽高而言的 */
      transform: translate(-50%, -50%);

      /* 白色背景 */
      background: white;
    }
  </style>
</head>
<body>
  <div class="center">
    用内容撑开盒子
  </div>
</body>
</html>
```

[运行案例](http://www.imooc.com/wiki/run/1180.html)点击 "运行案例" 可查看在线运行效果

运行结果：
![图片描述](http://img.mukewang.com/wiki/5ee2317e09ca221d03750812.jpg)

## 3. 小结

- margin 的百分比是相对于父元素的宽；
- translate 函数的百分比是相对于自身；
- 不仅适用于未知宽高，也同样适用于固定宽高的居中布局。

# 网格布局实现居中布局



## 1. 前言

本小节，我们将采用网格布局来实现居中布局的样式。

网格其实就是最近比较火的 Grid 布局，原理就是把父元素分割成一个个的小格子。

然后子元素指定自己具体在那个格子上，有点类似于表格布局。



## 2. 实例代码

通过网格布局实现移动端居中布局。

实例演示

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 令html和body全屏显示, 并有一个灰色背景 */
    html, body { height: 100%; background: gray; }

    /* 中央盒子的直接父元素 */
    body {
      /* 令其变成网格布局 */
      display: grid;

      /* 令子元素居中 */
      place-items: center;
    }

    .center {
	  /* 不用给宽高，但是可以给个内边距防止内容与盒子过于贴合 */
      padding: 10px;
      
      /* 白色背景 */
      background: white;
    }
  </style>
</head>
<body>
  <div class="center">用内容撑开盒子</div>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1176.html)点击 "运行案例" 可查看在线运行效果

运行结果：
![图片描述](http://img.mukewang.com/wiki/5ee71e1c098e4b9502810609.jpg)

估计大多数人都不太熟悉这个网格布局，它有些类似于表格布局，但比表格布局更加强大。

如果同学们对Grid不是很熟悉可以参考 [CSS3 Grid 布局](http://www.imooc.com/wiki/css3lesson/girdinfo.html)。

还有很多人担心 Grid 的兼容性：
![图片描述](http://img.mukewang.com/wiki/5ee22f9409019aef12020259.jpg)

其实可以看到绝大部分浏览器都已经支持了，即使是最被吐槽的 IE 浏览器，也可以通过增加 -ms-前缀来进行支持。
例如：`display: -ms-grid;`



## 3. 小结

Grid 布局是近些年来逐渐兴起的一种布局方式，它的功能十分强大。

用它可以轻松的实现响应式布局，以前要很多行代码很多行判断的复杂布局，在掌握了 Grid 之后也都不在话下。

# 弹性布局实现居中布局



## 1. 前言

[弹性布局](http://www.imooc.com/wiki/css3lesson/flex.html) 已经成为移动端最流行的布局方式之一了，本小节我们将会使用弹性布局的方式来实现我们的居中布局。



## 2. 实例代码

实例演示

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 令html和body全屏显示, 并有一个灰色背景 */
    html, body { height: 100%; background: gray; }

    /* 找到中央盒子的直接父元素 */
    body {
      /* 令其变成弹性布局 */
      display: flex;
    }

    .center {
      /* 自动外边距 */
      margin: auto;

      /* 白色背景 */
      background: white;

      /* 不用给宽高，但是可以给个内边距防止内容与盒子过于贴合 */
      padding: 10px;
    }
  </style>
</head>
<body>
  <div class="center">用内容撑开盒子</div>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1177.html)点击 "运行案例" 可查看在线运行效果

运行结果：

![图片描述](http://img.mukewang.com/wiki/5ee2338309baf8f503750812.jpg)



## 3. 小结

如果对弹性盒子不太了解的直接记住这俩要点即可：

- 父元素：`display: flex;`
- 子元素：`margin: auto;`

下一小节我们来讲一讲表格布局，顺便为了降低大家的学习成本，为大家推荐一个需要重点练会的布局，其他布局作为了解即可。

# 表格布局实现居中布局



## 1. 前言

其实 CSS 布局流行起来之前一直使用的是表格布局。

在居中布局这种场景下，表格布局也很适用。



## 2. 实例代码

来看看表格具体如何实现居中：

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    body {
      /* 令body全屏显示 */
      width: 100vw;
      height: 100vh;

      /* 显示为表格的格子 */
      display: table-cell;

      /* 水平居中 */
      text-align: center;

      /* 垂直居中 */
      vertical-align: middle;

      /* 灰色背景 */
      background: gray;
    }

    .center {
      /* 显示为行内块元素 */
      display: inline-block;

      /* 不用给宽高，但是可以给个内边距防止内容与盒子过于贴合 */
      padding: 10px;

      /* 白色背景 */
      background: white;
    }
  </style>
</head>
<body>
  <div class="center">用内容撑开盒子</div>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1181.html)点击 "运行案例" 可查看在线运行效果

运行结果：

![图片描述](http://img.mukewang.com/wiki/5ee2344c0963480401880406.jpg)

此布局的关键点在于：

- 父元素上 3 个样式设置：`display: table-cell; text-align: center; vertical-align: center;`；
- 子元素上设置`display: inline-block;`。



## 3. 小结

我知道看到这里很多同学都郁闷了：一个居中布局就这么多种方式，我得学到猴年马月才能记得住啊…

其实大可不必，方案过多虽然会导致有些懵，但如果我就为你指明一个方案呢？

重点练会一个方案，其他方案作为了解即可，这样是不是就感觉不那么困难了呢？

那么最推荐的就是最流行的同时也是代码量最少的：**弹性布局**方案。只要不是一些需要兼容很低版本浏览器的网站，你只需重点练会这一种就可以了。但如果你找了个非要兼容低版本浏览器的工作，那么推荐你**绝对定位**法。

本章我们带领大家用多种方式实现了居中布局，当然不仅仅只有这几种方式能够实现居中，但是这几种是目前来说最实用的。

其他没提到方式有的比较偏门，实际开发中很少用到。

# 单列布局简介



## 1. 前言

单列布局是目前运用最为广泛的布局之一，因其结构清晰、一目了然、无论屏幕大小都能获得较为一致的效果等优点深受大家喜爱。

接下来我们一起来看一看抽象模式的单列布局长什么样。



## 2. 单列布局

抽象成极简形式的单列布局长这样：
![图片描述](http://img.mukewang.com/wiki/5ee1b40109d427a103750812.jpg)
但极简形式大家看起来可能会有些陌生，那么我们在这一列里面加入许多行再看看：
![图片描述](http://img.mukewang.com/wiki/5ee1b4830a8ee89601840400.jpg)
这样看起来是不是就好多了呢？该种布局方式通常会在列里面放置许多行，每一行便代表了一个信息，并且左边通常都会配上一个图片以形成左图右文的形式：
![图片描述](http://img.mukewang.com/wiki/5ee1b4b409aabc2f04070740.jpg)
当点击具体的某一行时就会跳转到相应的二级页面。

单列布局通常用于首页等引导页面，陈列展示各种信息，点击后便跳转至具体的详情页面。



## 3. 实现手段

由于单列布局过于简单，并且可以用居中布局来进行代替，所以 [chinese-layout](https://www.yuque.com/vue-sharp/oco0rf/ded6m5) 并没有去实现这个布局。
不过这难不倒动手能力很强的我们，咱们一起来用各式各样、形态各异的 CSS 技术手工打造一个单列布局：

- [外边距法](https://www.imooc.com/wiki/mobilelayout/marginsingle.html)
- [弹性布局](https://www.imooc.com/wiki/mobilelayout/flexsingle.html)
- [绝对定位 + 平移](https://www.imooc.com/wiki/mobilelayout/absandtransingle.html)
- [网格布局](https://www.imooc.com/wiki/mobilelayout/gridsingle.html)
- [行内块元素](https://www.imooc.com/wiki/mobilelayout/inlineblock.html)
- [增光添彩](https://www.imooc.com/wiki/mobilelayout/colorful.html)



## 4. 小结

![图片描述](http://img.mukewang.com/wiki/5f87ede909b85d2810570534.jpg)
大家可以看看自己常去的网站是不是运用了这种布局，比如好多手机浏览器一打开就是一堆新闻广告之类。
仔细观察一下是不是单列布局，大家观察布局的时候要尽量将其抽象，不必关心内部的细节内容。

# 外边距实现单列布局



## 1. 前言

单列布局可以有很多种的方式去实现它，这一小节我们将运用最简单的 CSS 技术，然后由浅入深，最简单的 CSS 技术就代表了最优越的兼容性，无论多么老旧的浏览器，几乎都没有不认识外边距这个语法的。



## 2. 实例代码

这种方法不仅兼容性也非常的优异，同时也是最简单最好用的：

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 令html和body全屏显示, 并有一个灰色背景 */
    html, body { height: 100%; background: gray; }

    .center {
      /* 给个宽高方便查看 */
      width: 90%;
      height: 100%;

      /* 外边距上下为0、左右为自动 */
      margin: 0 auto;

      /* 白色背景 */
      background: white;
    }
  </style>
</head>
<body>
  <div class="center"></div>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1183.html)点击 "运行案例" 可查看在线运行效果

运行结果：

![图片描述](http://img.mukewang.com/wiki/5ee1b40109d427a103750812.jpg)

这样的一个最简单的单列布局就形成啦！



## 3. 小结

单列布局除了外边距法还有很多种方式可以去实现，下一小节我们就来讲解一下最最流行的弹性布局法。

# 弹性布局实现单列布局



## 1. 前言

弹性布局已经成为移动端最流行的布局方式之一了，还不了解的同学赶快去了解一下吧！本节我们就以弹性布局的方式实现单列布局。



## 2. 实例代码

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 令html和body全屏显示, 并有一个灰色背景 */
    html, body { height: 100%; background: gray; }

    /* 找到单列盒子的直接父元素 */
    body {
      /* 令其变成弹性布局 */
      display: flex;

      /* 水平方向居中 */
      justify-content: center;
    }

    .center {
      /* 相当于flex版的width: 90% */
      flex-basis: 90%;

      /* 白色背景 */
      background: white;
    }
  </style>
</head>
<body>
  <div class="center"></div>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1184.html)点击 "运行案例" 可查看在线运行效果

运行结果：

![图片描述](http://img.mukewang.com/wiki/5ee1b40109d427a103750812.jpg)



## 3. 小结

如果对弹性盒子不太了解的直接记住这几个要点即可：

1. 父元素设置 **display: flex**；
2. 水平方向属性为 **justify-content**；
3. 垂直方向属性为 **align-items**；

下一小节我们来讲一下绝对定位 + 平移来实现单列布局。

# 绝对定位 + 平移实现单列布局



## 1. 前言

平移是 CSS3 的属性，它可以按照自身尺寸的百分比来进行平移。

语法是：`transform: translate(xx%);`



## 2. 实例代码

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 令html和body全屏显示, 并有一个灰色背景 */
    html, body { height: 100%; background: gray; }

    /* 在祖先元素上设置相对定位 */
    body { position: relative }

    .center {
      /* 绝对定位 */
      position: absolute;

      /* 左方为50% */
      left: 50%;

      /* 给个宽高方便查看 */
      width: 90%;
      height: 100%;

      /* 这个50%是相对于自身宽高而言的 */
      transform: translate(-50%);

      /* 白色背景 */
      background: white;
    }
  </style>
</head>
<body>
  <div class="center"></div>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1185.html)点击 "运行案例" 可查看在线运行效果

运行结果：

![图片描述](http://img.mukewang.com/wiki/5ee1b40109d427a103750812.jpg)



## 3. 小结

只要涉及到绝对定位，就一定要记得在祖先元素上设置相对定位或其他定位。

不然的话可能不会按照你想要的方式去执行哦。

下一小节我们来讲解网格实现法。

# 网格布局实现单列布局



## 1. 前言

网格其实就是最近比较火的Grid布局，原理就是把父元素分割成一个个的小格子，然后子元素指定自己具体在那个格子上，有点类似于表格布局。



## 2. 实例代码

实例演示

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 令html和body全屏显示, 并有一个灰色背景 */
    html, body { height: 100%; background: gray; }

    /* 找到中央盒子的直接父元素 */
    body {
      /* 令其变成网格布局 */
      display: grid;

      /* 将其分成一行三列 */
      grid: 1fr / 1fr 10fr 1fr
    }

    .center {
      /* 将其定位于中间那个格子 */
      grid-area: 1 / 2 / 2 / 3;
      
      /* 白色背景 */
      background: white;
    }
  </style>
</head>
<body>
  <div class="center"></div>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1186.html)点击 "运行案例" 可查看在线运行效果

运行结果：

![图片描述](http://img.mukewang.com/wiki/5ee721990977630703720807.jpg)

将父元素分割成类似于表格一样的一个个格子，然后子元素指定自己具体待在哪个格子中：

![图片描述](http://img.mukewang.com/wiki/5ee721aa0917701903760812.jpg)



## 3. 小结

网格布局法十分强大，这里展现的仅仅只是九牛一毛。

下一小节我们将利用行内块元素来进行单列布局。

# 行内块元素实现单列布局



## 1. 前言

利用元素的行内元素特性我们可以很轻松的做到水平居中。

行内块的语法格式也很简单：`display: inline-block;`。



## 2. 实例代码

实例演示

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 令html和body全屏显示, 并有一个灰色背景 */
    html, body { height: 100%; background: gray; }

    body {
      /* 令子元素水平居中 */
      text-align: center;
      
      /* 灰色背景 */
      background: gray;
    }

    .center {
      /* 令其显示为行内块元素 */
      display: inline-block;

      /* 给个宽高方便查看 */
      width: 90%;
      height: 100%;

      /* 白色背景 */
      background: white;
    }
  </style>
</head>
<body>
  <div class="center"></div>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1187.html)点击 "运行案例" 可查看在线运行效果

运行结果：

![图片描述](http://img.mukewang.com/wiki/5ee1b40109d427a103750812.jpg)



## 3. 小结

**display: inline-block;** 可以让元素既拥有行内元素的特性，同时又拥有块级元素的特性。

不过看了这么多种方式的单列布局，可是看起来依然还是很抽象。

换句话说就是不好看，那么下一小节我们就为其添油加醋一下，使其看起来更加贴合实际。

# 增光添彩



## 1. 前言

单列布局是实现了，但是列里面通常都会放些什么呢？

一般来说列里面就都会放一些宽度和列相等、而高度随意的行，这里我们使用 [chinese-gradient](https://www.yuque.com/fancy-components/xflqsh/yxn4m7) 来进行颜色的填充并且拿之前讲过的**外边距法**来举例。



## 2. 实例代码

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 在这里用link标签引入中文渐变色 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-gradient">
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    body {
      /* 添加一个好看的背景色 */
      background: var(--墨色);
    }

    .center {
      /* 给个宽度方便查看 */
      width: 90%;

      /* 外边距上下为0、左右为自动 */
      margin: 0 auto;
    }
    
    /* 列中的行 */
    li {
      /* 清除默认样式 */
      list-style: none;

      /* 给一个合适的高度 */
      height: 100px;

      /* 给一个合适的外边距 */
      margin: 20px 0;

      /* 添加一个好看的背景色 */
      background: var(--灯红酒绿);
    }
  </style>
</head>
<body>
  <ul class="center">
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
  </ul>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1188.html)点击 "运行案例" 可查看在线运行效果

运行结果：

![图片描述](http://img.mukewang.com/wiki/5efaef8a0a9f2fff01850333.jpg)

要点就是在居中布局的那个盒子里面放置一堆子元素，然后宽 100% 充满父元素，这就相当于一行了，再设置一些合适的边距，使其不至于过分拥挤。



## 3. 小结

看完了该小节，我们已经对单列布局的各种实现方式都有所了解。具体的实现方式还要根据所处的环境择优使用。
下一章我们介绍一下移动端布局中的双列布局。

# 双列布局简介



## 1. 前言

网站单列 + 列中内容左图右文的形式已经可以满足很多场景的需要了。
但是有时候我们并不想要左图右文，左图右文重点突出的是文字，图片只是辅助。
而一些视频类、电商类网站需要重点突出的并不是文字，而是图片，这时候双列布局就派上用场了。



## 2. 双列布局

双列布局抽象起来通常是这样的：
![图片描述](http://img.mukewang.com/wiki/5ee1b5fa0a569df902050365.jpg)
由于现在的手机屏幕越来越大，可以容纳更多的信息，于是一些网站将自己的布局设置为双列的：
![图片描述](http://img.mukewang.com/wiki/5ee1b66d09ff624304120799.jpg)

图片来源于bilibili

但此种布局最好以图片为主，图片占比较大，文字占比较小。这样才能获得较为清晰的显示效果，文字通常是一句用来描述图片的标题。



## 3. 实现手段

一方面我们可以利用现有的CSS中文库：[chinese-layout](https://www.yuque.com/vue-sharp/oco0rf/ded6m5) 来快速实现双列布局：

- [中文布局 CSS 库](https://www.imooc.com/wiki/mobilelayout/muticol.html)

> 这种方式不仅利于我们的学习，更加有助于我们的记忆。

然后也会带领大家如何在不依赖于任何外界条件的情况下纯手工实现双列布局：

- [多列属性法](https://www.imooc.com/wiki/mobilelayout/float.html)
- [左浮动法](https://www.imooc.com/wiki/mobilelayout/absdouble.html)
- [绝对定位](https://www.imooc.com/wiki/mobilelayout/flexdouble.html)
- [弹性布局](https://www.imooc.com/wiki/mobilelayout/griddouble.html)
- [网格布局](https://www.imooc.com/wiki/mobilelayout/colorfuldouble.html)
- [增光添彩](https://www.imooc.com/wiki/mobilelayout/chinesedouble.html)



## 4. 小结

![图片描述](http://img.mukewang.com/wiki/5f87ee220979b56010360521.jpg)
该种布局常见于电商网站、视频网站等需要大量展示图片的网站。
因为如果没有图片作为主要展示的话，双列布局就会显得比较乱，不容易突出主题。

# 中文布局CSS库实现双列布局



## 1. 前言

借助市面上已有的CSS库，我们可以很轻易的做到双列布局，尤其是可以用到中文关键字，这非常有利于我们的记忆，它就是 [chinese-layout](https://www.yuque.com/react-hooks/oco0rf/ded6m5)。

然后我们再用一个中文渐变色的 CSS 库来美化我们的界面：[chinese-gradient](https://www.yuque.com/react-hooks/xflqsh/yxn4m7)。



## 2. 实例代码

要点就是在 **head** 标签中用 **link** 标签引入[chinese-gradient](https://www.yuque.com/vue-sharp/xflqsh/yxn4m7) 和 [chinese-layout](https://www.yuque.com/vue-sharp/oco0rf/ded6m5)，
然后就可以使用中文关键字啦：

实例演示

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 在这里用link标签引入中文布局 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-layout">

  <!-- 在这里用link标签引入中文渐变色 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-gradient">
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 令html和body全屏显示 */
    html, body { height: 100%; }

    body {
      /* 先在父元素上设置grid布局 */
      display: grid;
      grid: var(--双列);
      gap: 10px;

      /* 给个左右内边距 */
      padding: 0 10px;
    } 

    div {
      /* 给一个好看的背景色 */
      background: var(--湖蓝);
    }
  </style>
</head>
<body>
  <div class="left"></div>
  <div class="right"></div>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1189.html)点击 "运行案例" 可查看在线运行效果

运行结果：
![图片描述](http://img.mukewang.com/wiki/5efaf84f0916024602810500.jpg)



## 3. 小结

怎么样？用CSS库是不是很简单呢？

但是我们不仅要学会CSS库的用法，还要学会在不依赖外部条件的情况下进行纯手写，所以下一小节我们开始讲原生CSS的写法。

# 多列属性实现双列布局



## 1. 前言

这是一个经常被忽略的一个属性，因为很少有人知道，或者说大部分人仅仅只是知道，但并没有使用过。

它的语法形式是酱紫的：`columns: 2(列数);`。



## 2. 实现

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 令html和body全屏显示, 并有一个灰色背景 */
    html, body { height: 100%; background: gray; }

    /* 找到直接父元素 */
    body {
      /* 将列数设置为2 */
      columns: 2;
      
      /* 设置列间距 */
      column-gap: 10px;
    }

    div {
      /* 给个高度 */
      height: 100%;

      /* 白色背景 */
      background: white;
    }

    /* 左边盒子设置左边距 */
    .left { margin-left: 10px; }

    /* 右边盒子设置右边距 */
    .right { margin-right: 10px; }
  </style>
</head>
<body>
  <div class="left"></div>
  <div class="right"></div>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1190.html)点击 "运行案例" 可查看在线运行效果

运行结果：

![图片描述](http://img.mukewang.com/wiki/5ee7297909b1422a01880406.jpg)



## 3. 小结

多列属性 **columns** 是 CSS3 的新增属性。

但它却并不像其他 CSS3 新属性（如 transform）知名度那么高，甚至很多人都不知道还有这么个玩意，大家有空的话可以去了解一下。

# 左浮动实现双列布局



## 1. 前言

在之前 CSS 不发达的那个年代，浮动（ float ）可是当之无愧的布局利器，非常经典的一个属性。

来看看用它是怎么实现双列布局的吧。



## 2. 实现

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 令html和body全屏显示, 并有一个灰色背景 */
    html, body { height: 100%; background: gray; }

    div {
      /* 给个高度 */
      width: 47%;

      /* 给个高度 */
      height: 100%;

      /* 白色背景 */
      background: white;
    }

    /* 左边盒子 */
    .left {
      /* 左浮动 */
      float: left;
      
      /* 给个合适的左边距 */
      margin-left: 2%;
    }

    /* 右边盒子 */
    .right {
      float: right;

      /* 给个合适的右边距 */
      margin-right: 2%;
    }
  </style>
</head>
<body>
  <div class="left"></div>
  <div class="right"></div>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1191.html)点击 "运行案例" 可查看在线运行效果

运行结果：

![图片描述](http://img.mukewang.com/wiki/5ee7371a0924843402820611.jpg)



## 3. 小结

和其他的浮动一样，这种方法会导致父元素的坍塌。

如果两列下面还有元素的话，记得要清除浮动哦。

# 绝对定位实现双列布局



## 1. 前言

无论什么布局几乎都可以使用绝对定位来实现，那为什么好多布局并不会首选绝对定位呢？

一方面是因为写起来可能有点麻烦，另一方面是因为必须得`算`，那具体要怎么`算`呢？

看来实现你就明白了。



## 2. 实例代码

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 令html和body全屏显示, 并有一个灰色背景 */
    html, body { height: 100%; background: gray; }

    /* 在父元素上设置相对定位 */
    body { position: relative; }

    div {
      /* 绝对定位 */
      position: absolute;

      /* 令其上下方向与父元素的距离为0 */
      top: 0;
      bottom: 0;

      /* 白色背景 */
      background: white;
    }

    /* 左边的列 */
    .left {
      /* 令其左侧方向与父元素的距离为2% */
      left: 2%;

      /* 令其右侧方向与父元素的距离为51% */
      right: 51%;
    }

    /* 右边的列 */
    .right {
      /* 令其左侧方向与父元素的距离为51% */
      left: 51%;

      /* 令其右侧方向与父元素的距离为2% */
      right: 2%;
    }
  </style>
</head>
<body>
  <div class="left"></div>
  <div class="right"></div>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1192.html)点击 "运行案例" 可查看在线运行效果

运行结果：

![图片描述](http://img.mukewang.com/wiki/5ee73a2a0955d2f901880406.jpg)



## 3. 小结

这里加起来不等于 100%，因为这里的百分号指的不是宽度，而是相对于父元素的距离。

那这该怎么算呢？其实也简单，我们在屏幕正中央位置画一条线，这条线就代表距离左边 50%、距离右边也是 50%：

![图片描述](http://img.mukewang.com/wiki/5ee7355b097b7ddf05620100.jpg)

然后左边 2%、右边 2%、中间 2%，但是中间的 2% 被平分成了两个 1%，我们再画几条线看一下：

![图片描述](http://img.mukewang.com/wiki/5ee7356a09317b2508130142.jpg)

左边的红线代表 **left: 2%;**，右边的两条绿线加在一起就是 51%，代表 **right: 51%**；

其实就是一道简单的数学题，算好百分比就可以用绝对定位啦！

# 弹性布局实现双列布局



## 1. 前言

弹性布局已经成为移动端最流行的布局方式之一了，还不了解的同学赶快去了解一下吧！

本小节就会带领大家一起用最流行的方式来实现双列布局。



## 2. 实例代码

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 令html和body全屏显示, 并有一个灰色背景 */
    html, body { height: 100%; background: gray; }

    /* 找到直接父元素 */
    body {
      /* 显示为弹性盒子 */
      display: flex;

      /* 令其子元素在水平方向上均匀分布 */
      justify-content: space-evenly;
    }

    div {
      /* 这里类似于width: 48% */
      flex-basis: 48%;

      /* 给个高度 */
      height: 100%;

      /* 白色背景 */
      background: white;
    }
  </style>
</head>
<body>
  <div></div>
  <div></div>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1193.html)点击 "运行案例" 可查看在线运行效果

运行结果：

![图片描述](http://img.mukewang.com/wiki/5ee73a2a0955d2f901880406.jpg)



## 3. 小结

子元素一般会用 **flex-basis** 属性来表示在父元素所占的长度。

因为 flex 盒子不仅有横着的，还会有竖着的。假如竖着的再叫宽就不太合适了，所以取了 **flex-basis** 这么一个名字作为新的属性来表示长度( *横着的时候代表宽，竖着的时候代表高* )。

# 网格布局实现双列布局



## 1. 前言

网格其实就是最近比较火的 Grid 布局，原理就是把父元素分割成一个个的小格子，然后子元素指定自己具体在那个格子上，有点类似于表格布局。



## 2. 实现

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 令html和body全屏显示, 并有一个灰色背景 */
    html, body { height: 100%; background: gray; }

    /* 找到直接父元素 */
    body {
      /* 显示为网格布局 */
      display: grid;

      /* 设置垂直方向为两列 */
      grid-template-columns: repeat(2, 1fr);

      /* 列之间的间距为10像素 */
      gap: 10px;
    }

    div {
      /* 给个高度 */
      height: 100%;

      /* 白色背景 */
      background: white;
    }
  </style>
</head>
<body>
  <div></div>
  <div></div>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1194.html)点击 "运行案例" 可查看在线运行效果

运行结果：

![图片描述](http://img.mukewang.com/wiki/5ee877620972cf6503750812.jpg)

可以看到这个列间距只会针对于列与列之间的距离，所以这两列和屏幕之间的距离为 0，那么该如何进行改进呢：

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 令html和body全屏显示, 并有一个灰色背景 */
    html, body { height: 100%; background: gray; }

    /* 找到直接父元素 */
    body {
      /* 显示为网格布局 */
      display: grid;

      /* 设置垂直方向为五列 */
      grid-template-columns: repeat(2, 10px 1fr) 10px;
    }

    div {
      /* 给个高度 */
      height: 100%;

      /* 白色背景 */
      background: white;
    }

    /* 设置左侧列的位置 */
    .left { grid-area: 1 / 2 / 2 / 3; }

    /* 设置右侧列的位置 */
    .right { grid-area: 1 / 4 / 2 / 5; }
  </style>
</head>
<body>
  <div class="left"></div>
  <div class="right"></div>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1195.html)点击 "运行案例" 可查看在线运行效果

运行结果：

![图片描述](http://img.mukewang.com/wiki/5ee7297909b1422a01880406.jpg)



## 3. 小结

其实原理也很简单，我们把间距也设置成一列，这样的话算上间距一共就五列了：

![图片描述](http://img.mukewang.com/wiki/5ee877ff09d19fed06190138.jpg)

然后将左侧列设置为父元素的第二列，右侧列设置为父元素的第四列即可。

# 增光添彩



## 1. 前言

既然两个列都已经出现了，那么列里面的元素写法跟单列布局列中的元素写法差不多。

本节我们将会拿**弹性盒子**来举例。



## 2. 实例代码

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 在这里用link标签引入中文渐变色 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-gradient">
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 找到直接父元素 */
    body {
      /* 显示为弹性盒子 */
      display: flex;

      /* 令其子元素在水平方向上均匀分布 */
      justify-content: space-evenly;

      /* 给一个好看的背景色 */
      background: var(--霾灰);
    }

    ul {
      /* 这里类似于width: 42% */
      flex-basis: 42%;

      /* 给个高度 */
      height: 100%;
    }

    li {
      /* 清除默认样式 */
      list-style: none;

      /* 给个合适的高度 */
      height: 150px;

      /* 给个合适的外边距 */
      margin: 20px 0;

      /* 给一个好看的背景色 */
      background: var(--极光绿);
    }
  </style>
</head>
<body>
  <ul>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
  </ul>
  <ul>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
  </ul>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1196.html)点击 "运行案例" 可查看在线运行效果

运行结果：

![图片描述](http://img.mukewang.com/wiki/5efb0bc80a876b4501850333.jpg)

虽然现在这么看起来可能并不好看，但是只要在每个格子里放入一张图片就会好看许多。

那么这个任务就作为一个课后练习题交给大家，同学们一定要动手实验一下啊！



## 3. 结语

当然了，双列布局可以在单列布局的基础上，在单列里面再写两个列，但是这样会多出来一个 DOM 元素，影响性能。

所以本章并没有采用单列里面再加双列的布局方式，但是对性能要求不是特别严格的场景下也可以采用单列内部添加双列的这么一种方式，

大家可以灵活运用这两章学到的知识去尝试一下。

# 吕形布局简介



## 1. 前言

顾名思义，吕字就是上面一个矩形，下面一个矩形。上面的矩形高度较小，通常固定在屏幕上，不会随着用户滑动手机而进行任何的移动。

目前流行的方案一种是直接默认显示上栏，另一种是随着屏幕的滑动而慢慢显示出上栏。



## 2. 吕形布局

我们来展示与一下吕形布局的效果以及它的使用场景。

吕形布局抽象起来是酱婶儿的：
![图片描述](http://img.mukewang.com/wiki/5ee1b76d09c1b73902580462.jpg)
一般会把跳转页面、搜索、下载或者历史记录等功能放在上面固定在屏幕上的矩形内，可以简单的把它理解为标题或功能区：
![图片描述](http://img.mukewang.com/wiki/5ee1b78a094bd05004100726.jpg)
上面的矩形宽度充满屏幕，并提供一系列的按钮，每当点击时上方矩形按钮时下方矩形就会跳转到另一个页面，通常上方的一排按钮会有其中一个高亮显示，以告知用户当前所在的页面是哪一个。



## 3. 渐隐渐现

除了上面几种方式实现吕形布局外，为了增加交互效果，我们还可能会把吕形布局做成随着屏幕的滑动而渐隐渐现的这么一种效果：
![图片描述](http://img.mukewang.com/wiki/5efc2e5c0aa5efad01840330.jpg)
这种效果主要是通过了JS来获取到屏幕的滚动距离，然后随着距离的增加来动态控制透明度，增加了交互的趣味性。



## 4. 实现手段

一方面我们可以利用现有的 CSS 中文库：[chinese-layout](https://www.yuque.com/vue-sharp/oco0rf/ded6m5) 来快速实现吕形布局：

- [中文布局 CSS 库](https://www.imooc.com/wiki/mobilelayout/chineselv.html)

> 这种方式不仅利于我们的学习，更加有助于我们的记忆。

然后也会带领大家如何在不依赖于任何外界条件的情况下纯手工实现吕形布局：

- [固定定位法](https://www.imooc.com/wiki/mobilelayout/defaultlv.html)
- [外边距的作用](https://www.imooc.com/wiki/mobilelayout/margin.html)
- [非固定定位](https://www.imooc.com/wiki/mobilelayout/unfixed.html)

作为扩展阅读，我们还提供了交互更加充满趣味性的渐隐渐现效果：

- [固定定位 + 渐隐渐现](https://www.imooc.com/wiki/mobilelayout/fixedshow.html)

> 不过由于渐隐渐现效果必须用 JS 才能获取到当前页面的滚动距离，所以这章只作为扩展阅读，防止没有 JS 基础的小伙伴看了懵圈。



## 5. 小结

![图片描述](http://img.mukewang.com/wiki/5f87ee3709ff28bf10420500.jpg)
大家可以记住吕形布局的抽象图，然后在玩手机的时候可以看看都有哪些网站运用到了吕形布局。

# 中文布局CSS库实现吕形布局



## 1. 前言

借助市面上已有的CSS库，我们可以很轻易的做到吕形布局，尤其是可以用到中文关键字，这非常有利于我们的记忆，它就是 [chinese-layout](https://www.yuque.com/react-hooks/oco0rf/ded6m5)。

然后我们再用一个中文渐变色的 CSS 库来美化我们的界面：[chinese-gradient](https://www.yuque.com/react-hooks/xflqsh/yxn4m7)。



## 2. 实例代码

要点就是在 **head** 标签中用 **link** 标签引入 [chinese-gradient](https://www.yuque.com/react-hooks/xflqsh/yxn4m7) 和 [chinese-layout](https://www.yuque.com/react-hooks/oco0rf/ded6m5)。
然后就可以使用中文关键字啦：

实例演示

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 在这里用link标签引入中文布局 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-layout">

  <!-- 在这里用link标签引入中文渐变色 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-gradient">
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 令html和body全屏显示 */
    html, body { height: 100%; }

    body {
      /* 先在父元素上设置grid布局 */
      display: grid;
      grid: var(--吕形);

      /* 给个合适的间距 */
      gap: 5px;
    }

    /* 上栏 */
    .top {
      /* 给个高度或者用内容撑开，不然的话高度会变成0 */
      height: 60px;

      /* 给个好看的渐变色 */
      background: var(--紫灰);
    }

    /* 下栏 */
    .bottom {
      /* 下栏会根据上栏的高度自适应，所以不用写高度 */
      /* 给个好看的渐变色 */
      background: var(--极光绿);

	  /* 竖直方向超出部分会出现滚动条 */
      overflow-y: auto
    }
  </style>
</head>
<body>
  <div class="top"></div>
  <div class="bottom"></div>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1197.html)点击 "运行案例" 可查看在线运行效果

运行结果：
![图片描述](http://img.mukewang.com/wiki/5efbf9610905d73202810500.jpg)



## 3. 小结

怎么样？用 CSS 库是不是很简单呢？

但是我们不仅要学会 CSS 库的用法，还要学会在不依赖外部条件的情况下进行纯手写，所以下一小节我们来讲讲原生 CSS 的写法。

# 固定定位实现吕形布局



## 1. 前言

吕形布局的上栏通常是不会消失的，它会一直存在在屏幕上，将上栏固定在屏幕的特定位置，然后下栏添加合适的上边距。

一听到要把什么东西固定在屏幕上的话，那么第一时间脑海里反应出来的应该就是固定定位。



## 2. 实例代码

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 在这里用link标签引入中文渐变色 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-gradient">
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 令html和body全屏显示 */
    html, body { height: 100% }

    /* 上面的那栏 */
    .top {
      /* 设置为固定定位 */
      position: fixed;

      /* 距离上边左边为0 */
      top: 0;
      left: 0;

      /* 宽度铺满屏幕 */
      width: 100%;

      /* 给个合适的高度 */
      height: 80px;

      /* 白色文字 */
      color: white;

      /* 蓝色背景 */
      background: var(--靛蓝);
    }

    .main {
      /* 给个合适的上边距 */
      margin-top: 90px;

      /* 给个合适的高度 */
      height: 1000px;

      /* 渐变背景 */
      background: var(--天蓝);
    }
  </style>
</head>
<body>
  <div class="top" style="font-size: 30px;">无论你怎么滑动屏幕，我都是固定不变的</div>
  <div class="main"></div>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1199.html)点击 "运行案例" 可查看在线运行效果

运行结果：

![图片描述](http://img.mukewang.com/wiki/5efbfd9f0a90084701850333.jpg)

为了能让大家清晰的看到滑动效果，这个案例使用了 [chinese-gradient](https://www.yuque.com/fancy-components/xflqsh/yxn4m7) 来做背景渐变色。



## 3. 小结

大家在做这个案例的时候最好在元素内写上一些文字或者填充一些渐变色来获得更清晰的显示效果。

下一小节我们来讲讲为什么要在下面的 DOM 元素上写一个上边距。

# 外边距的作用



## 1. 前言

为什么要有一个合适的外边距呢？

其实根本原因在于固定定位会脱离默认文档流，为了让大家清楚的认识到到底是怎么一回事，我们特意在主盒子的里面写上了一些文字。



## 2. 加入文字

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 在这里用link标签引入中文渐变色 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-gradient">
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 令html和body全屏显示 */
    html, body { height: 100% }

    /* 上面的那栏 */
    .top {
      /* 设置为固定定位 */
      position: fixed;

      /* 距离上边左边为0 */
      top: 0;
      left: 0;

      /* 宽度铺满屏幕 */
      width: 100%;

      /* 给个合适的高度 */
      height: 80px;

      /* 蓝色背景 */
      background: var(--靛蓝);
    }

    .main {
      /* 给个合适的上边距 */
      margin-top: 90px;

      /* 给个合适的高度 */
      height: 1000px;

      /* 渐变背景 */
      background: var(--天蓝);
    }

    /* 让盒子里的文字变成白色 */
    div { color: white }
  </style>
</head>
<body>
  <div class="top" style="font-size: 30px;">无论你怎么滑动屏幕，我都是固定不变的</div>
  <div class="main" style="font-size: 30px;">
    这里是主盒子
  </div>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1200.html)点击 "运行案例" 可查看在线运行效果

运行结果：

![图片描述](http://img.mukewang.com/wiki/5efc02b80a8abca701850333.jpg)



## 3. 去掉主盒子的外边距

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 在这里用link标签引入中文渐变色 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-gradient">
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 令html和body全屏显示 */
    html, body { height: 100% }

    /* 上面的那栏 */
    .top {
      /* 设置为固定定位 */
      position: fixed;

      /* 距离上边左边为0 */
      top: 0;
      left: 0;

      /* 宽度铺满屏幕 */
      width: 100%;

      /* 给个合适的高度 */
      height: 80px;

      /* 蓝色背景 */
      background: var(--靛蓝);

      /* 运行动画 */
      animation: hide 2s ease-in infinite alternate
    }

    .main {
      /* 给个合适的上边距 */
      margin-top: 90px;

      /* 给个合适的高度 */
      height: 100%;

      /* 渐变背景 */
      background: var(--天蓝);

      /* 运行动画 */
      animation: move 2s ease-in infinite alternate
    }

    /* 让盒子里的文字变成白色 */
    div { color: white }

    @keyframes move { to { margin-top: 0 } }
    @keyframes hide {
      from { opacity: .7 }
      to { opacity: .5 }
    }
  </style>
</head>
<body>
  <div class="top" style="font-size: 30px;">无论你怎么滑动屏幕，我都是固定不变的</div>
  <div class="main" style="font-size: 30px;">
    这里是主盒子
  </div>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1202.html)点击 "运行案例" 可查看在线运行效果

运行结果：





## 4. 小结

这是怎么回事呢？原来，去掉了外边距就相当于把盒子推到了最顶端：
![图片描述](http://img.mukewang.com/wiki/5efc25dd09b5251901890339.jpg)
为了让大家能看清楚是怎么回事，所以在头部添加了透明度。如果没加透明度的话便会产生遮挡：
![图片描述](http://img.mukewang.com/wiki/5efc26ad0945f65201870330.jpg)
也就是说：固定定位的盒子不占用任何的空间（脱离默认文档流），所以为了弥补这段失去的空间，我们应该在主盒子上加入一个上边距。

# 非固定定位实现吕形布局



## 1. 前言

除了将上栏固定在屏幕上，我们还有另一种选择，那就是上栏和主盒子都在屏幕的那个位置不动，那有人可能会说了，主盒子里的内容要是多了，超出了屏幕的高度该怎么办呢？这就要用到一个属性叫做 **overflow-y**。



## 2. 实现

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 在这里用link标签引入中文渐变色 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-gradient">
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 令html和body全屏显示 */
    html, body { height: 100% }

    /* 上面的那栏 */
    .top {
      /* 设置一个合适的高度 */
      height: 10%;

      /* 蓝色背景 */
      background: var(--靛蓝);
    }

    /* 主显示区 */
    .main {
      /* 给个合适的高度 */
      height: 90%;

      /* 给个好看的渐变色 */
      background: var(--天蓝);

      /* 竖直方向的溢出设置为自动 */
      overflow-y: auto;
    }

    /* 盒子的默认样式 */
    div {
      font-size: 30px;
      color: white;
    }
  </style>
</head>
<body>
  <div class="top"></div>
  <div class="main">
    这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子
  </div>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1204.html)点击 "运行案例" 可查看在线运行效果

运行结果：
![图片描述](http://img.mukewang.com/wiki/5efd88760a75a83a01840330.jpg)
可以看到这个案例虽然文字撑开了内容导致溢出，然后出现滚动条可以上下滚动，但背景色却没有变化，这是因为我们是在主盒子上面加的背景色。
这种靠子元素来撑开内容的溢出应该把样式全部写在子元素上面去，父元素只提供一个高度和一个 **overflow-y** 即可：

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 在这里用link标签引入中文渐变色 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-gradient">
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 令html和body全屏显示 */
    html, body { height: 100% }

    /* 上面的那栏 */
    .top {
      /* 设置一个合适的高度 */
      height: 10%;

      /* 蓝色背景 */
      background: var(--靛蓝);
    }

    /* 主显示区 */
    .main {
      /* 给个合适的高度 */
      height: 90%;

      /* 竖直方向的溢出设置为自动 */
      overflow-y: auto;
    }

    .child {
      height: 1000px;

      /* 给个好看的渐变色 */
      background: var(--天蓝);
    }

    /* 盒子的默认样式 */
    div {
      font-size: 30px;
      color: white;
    }
  </style>
</head>
<body>
  <div class="top"></div>
  <div class="main">
    <div class="child"></div>
  </div>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1205.html)点击 "运行案例" 可查看在线运行效果

运行结果：
![图片描述](http://img.mukewang.com/wiki/5efd89d10a3d06ba01840330.jpg)



## 3. 小结

这里一定要记住这几个要点：

- 上栏和下栏的宽度加起来要刚好是屏幕的高度；
- 下栏一定要写 **overflow-y: auto**；
- 下栏的背景什么的最好写在子元素上，除非你就是想要这种背景不动的效果。

# 固定定位+渐隐渐现



## 1. 前言

相信大家日常用手机的时候会见过这种页面：
![图片描述](http://img.mukewang.com/wiki/5efc2b040a2503b902730072.jpg)
这个需求也比较常见，而且这个交互效果看起来会更加的友好，不过需要用到一点点的 JS 来获取页面滚动的距离，不会 JS 的同学先不要紧张，看不懂的话可以先记住怎么用就行。



## 2. 实例代码

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 在这里用link标签引入中文渐变色 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-gradient">
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0 }

    /* 令html和body全屏显示 */
    html, body { height: 100% }

    /* 上面的那栏 */
    .top {
      /* 设置为固定定位 */
      position: fixed;

      /* 距离上边左边为0 */
      top: 0;
      left: 0;

      /* 宽度铺满屏幕 */
      width: 100%;

      /* 给个合适的高度 */
      height: 80px;

      /* 令其透明 */
      opacity: 0;

      /* 蓝色背景 */
      background: var(--靛蓝);
    }

    .main {
      /* 给个合适的高度 */
      height: 1000px;

      /* 渐变背景 */
      background: var(--湖蓝);
    }
  </style>
</head>
<body>
  <div class="top"></div>
  <div class="main"></div>

  <script>
    // 获取固定栏
    const dom = document.getElementsByClassName('top')[0]

    window.addEventListener('scroll', _ => {
      // 获取偏移值
      const top = document.documentElement.scrollTop

      // 设置一个合适的范围
      if (top <= 150) {
        // 对opacity作计算，透明度从起始到1随偏移值而改变
        const opacity = top / 150

        // 令上栏的透明度变成计算后的透明度
        dom.style.opacity = opacity
      } else {
        // 在移动一定范围后令其完全不透明
        dom.style.opacity = 1
      }
    })
  </script>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1203.html)点击 "运行案例" 可查看在线运行效果

运行结果：

![图片描述](http://img.mukewang.com/wiki/5efc2e5c0aa5efad01840330.jpg)
为了能让大家清晰的看到滑动效果，这个案例使用了 [chinese-gradient](https://www.yuque.com/fancy-components/xflqsh/yxn4m7) 来做背景渐变色。

> 这里就不用再给主盒子加上边距啦，因为在最上面的时候上栏是透明的，不会覆盖住内容的。



## 3. 结语

怎么样，是不是很炫酷呢？不过可惜无法用 CSS 来判断屏幕滑动了多少距离，所以渐隐渐现的效果用到了一点点的 JS。

# 上下栏布局简介



## 1. 前言

顾名思义，上下栏就是上面一个栏，下面一个栏，中间的区域填满剩余空间。上下两栏的矩形高度较小，通常固定在屏幕上，不会随着用户滑动手机而进行任何的移动。

如果同学们学会了上一章的吕型布局，那么这一章简直就是手到擒来，唯一和上一章有点区别的就是下面多了一个固定栏。



## 2. 上下栏布局

抽象版上下栏布局是这样的：
![图片描述](http://img.mukewang.com/wiki/5ee1aee5094de96c03780678.jpg)
该种布局方式比吕形布局多了一行，上下两行都是宽度充满屏幕，高度固定。

不会随着用户滚动屏幕的操作而进行移动：
![图片描述](http://img.mukewang.com/wiki/5ee1b9450929767304090860.jpg)



## 3. 渐隐渐现

除了上面几种方式实现上下栏布局外，为了增加交互效果，我们还可能会把上下栏布局做成随着屏幕的滑动而渐隐渐现的这么一种效果：
![图片描述](http://img.mukewang.com/wiki/5f041f760a31eb5d01840330.jpg)
这种效果主要是通过了JS来获取到屏幕的滚动距离，然后随着距离的增加来动态控制透明度，增加了交互的趣味性。



## 4. 实现手段

一方面我们可以利用现有的CSS中文库：[chinese-layout](https://www.yuque.com/vue-sharp/oco0rf/ded6m5) 来快速实现上下栏布局：

- [中文布局 CSS 库](http://www.imooc.com/wiki/mobilelayout/chinesetop.html)

> 这种方式不仅利于我们的学习，更加有助于我们的记忆。

然后也会带领大家如何在不依赖于任何外界条件的情况下纯手工实现上下栏布局：

- [固定定位法](http://www.imooc.com/wiki/mobilelayout/fixedtop.html)
- [外边距的作用](http://www.imooc.com/wiki/mobilelayout/marginfunc.html)
- [非固定定位](http://www.imooc.com/wiki/mobilelayout/unfixedtop.html)

作为扩展阅读，我们还提供了交互更加充满趣味性的渐隐渐现效果：

- [固定定位 + 渐隐渐现](http://www.imooc.com/wiki/mobilelayout/hidetop.html)

> 不过由于渐隐渐现效果必须用 JS 才能获取到当前页面的滚动距离，所以最后这一小节只作为扩展阅读，防止没有 JS 基础的小伙伴看了懵圈。



## 5. 小结

![图片描述](http://img.mukewang.com/wiki/5f87ee61091b924410440472.jpg)

上下栏布局使用多种筛选，排序，底部导航；

上下栏布局可以迅速切换，减少跳转；

上下栏布局实现方法：固定定位，外边距，非固定定位；

上下栏布局可以为用户提供更加丰富的操作，通常用于业务需求略复杂的网站。

下一小节我们就来讲讲如何用代码去实现一个上下栏布局。

# 上下栏布局中文布局CSS库



## 1. 前言

如果同学们学会了上一章的吕型布局，那么这一章简直就是手到擒来，唯一和上一章有点区别的就是下面多了一个固定栏。

借助市面上已有的 CSS 库，我们可以很轻易的做到上下栏布局，尤其是可以用到中文关键字，这非常有利于我们的记忆，它就是 [chinese-layout](https://www.yuque.com/react-hooks/oco0rf/ded6m5)。

然后我们再用一个中文渐变色的 CSS 库来美化我们的界面：[chinese-gradient](https://www.yuque.com/react-hooks/xflqsh/yxn4m7)。



## 2. 用法

要点就是在 **head** 标签中用 **link** 标签引入 [chinese-gradient](https://www.yuque.com/react-hooks/xflqsh/yxn4m7) 和 [chinese-layout](https://www.yuque.com/react-hooks/oco0rf/ded6m5)。
然后就可以使用中文关键字啦：

实例演示

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 在这里用link标签引入中文布局 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-layout">

  <!-- 在这里用link标签引入中文渐变色 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-gradient">
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 令html和body全屏显示 */
    html, body { height: 100%; }

    body {
      /* 先在父元素上设置grid布局 */
      display: grid;
      grid: var(--上下栏);

      /* 给个合适的间距 */
      gap: 5px;
    }

    /* 上栏和下栏 */
    .top, .bottom {
      /* 给个高度或者用内容撑开，不然的话高度会变成0 */
      height: 60px;

      /* 给个好看的渐变色 */
      background: var(--紫灰);
    }

    /* 中间 */
    .center {
      /* 中间会根据上下栏的高度自适应，所以不用写高度 */
      /* 给个好看的渐变色 */
      background: var(--极光绿);

	  /* 竖直方向如有超出则会出现滚动条 */
      overflow-y: auto
    }
  </style>
</head>
<body>
  <div class="top"></div>
  <div class="center"></div>
  <div class="bottom"></div>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1214.html)点击 "运行案例" 可查看在线运行效果

运行结果：
![图片描述](http://img.mukewang.com/wiki/5f02d12d09baf3bb02810500.jpg)



## 3. 小结

怎么样？用 CSS 库是不是很简单呢？

但是我们不仅要学会 CSS 库的用法，还要学会在不依赖外部条件的情况下进行纯手写，所以下一小节我们来讲讲原生 CSS 的写法。

# 固定定位实现上下栏布局



## 1. 前言

上下栏通常是一直存在在屏幕上，将上下栏固定在屏幕的特定位置，然后为内容添加合适的边距。

一听到要把什么东西固定在屏幕上的话，那么第一时间脑海里反应出来的应该就是固定定位。



## 2. 实现

将上栏以及下栏固定在屏幕的特定位置，然后主盒子添加合适的上下边距：

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 在这里用link标签引入中文渐变色 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-gradient">
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 令html和body全屏显示 */
    html, body { height: 100% }

    /* 设置父元素为相对定位 */
    body { position: relative; }

    /* 上面的那栏 */
    .top {
      /* 设置为固定定位 */
      position: fixed;

      /* 距离上边左边为0 */
      top: 0;
      left: 0;

      /* 宽度铺满屏幕 */
      width: 100%;

      /* 给个合适的高度 */
      height: 80px;

      /* 绿色背景 */
      background: var(--极光绿);
    }

    .main {
      /* 给个合适的上下边距 */
      margin: 90px 0;

      /* 给个合适的高度 */
      height: 1000px;

      /* 渐变背景 */
      background: var(--灯红酒绿);
    }

    /* 下面的那栏 */
    .bottom {
      /* 设置为固定定位 */
      position: fixed;

      /* 距离下边左边为0 */
      bottom: 0;
      left: 0;

      /* 宽度铺满屏幕 */
      width: 100%;

      /* 给个合适的高度 */
      height: 80px;

      /* 黄色背景 */
      background: var(--芒果黄);
    }

    div {
      /* 白色文字 */
      color: white;

      /* 字体大小 */
      font-size: 30px
    }
  </style>
</head>
<body>
  <div class="top">无论你怎么滑动屏幕，我都是固定不变的</div>
  <div class="main">
    主盒子顶部
  </div>
  <div class="bottom">无论你怎么滑动屏幕，我都是固定不变的</div>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1215.html)点击 "运行案例" 可查看在线运行效果

运行结果：
![图片描述](http://img.mukewang.com/wiki/5f03ea9f0ad556f801840330.jpg)



## 3. 小结

大家在做这个案例的时候最好在元素内写上一些文字或者填充一些渐变色来获得更清晰的显示效果。

下一小节我们来讲讲为什么要在中间的 DOM 元素上写一个上下边距。

# 外边距的作用



## 1. 前言

为什么要有一个合适的外边距呢？

我们在主盒子里面写上一些文字看看：



## 2. 加入文字

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 在这里用link标签引入中文渐变色 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-gradient">
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 令html和body全屏显示 */
    html, body { height: 100% }

    /* 设置父元素为相对定位 */
    body { position: relative; }

    /* 上面的那栏 */
    .top {
      /* 设置为固定定位 */
      position: fixed;

      /* 距离上边左边为0 */
      top: 0;
      left: 0;

      /* 宽度铺满屏幕 */
      width: 100%;

      /* 给个合适的高度 */
      height: 80px;

      /* 绿色背景 */
      background: var(--极光绿);
    }

    .main {
      /* 给个合适的上下边距 */
      margin: 90px 0;

      /* 给个合适的高度 */
      height: 1000px;

      /* 渐变背景 */
      background: var(--灯红酒绿);
    }

    /* 下面的那栏 */
    .bottom {
      /* 设置为固定定位 */
      position: fixed;

      /* 距离下边左边为0 */
      bottom: 0;
      left: 0;

      /* 宽度铺满屏幕 */
      width: 100%;

      /* 给个合适的高度 */
      height: 80px;

      /* 黄色背景 */
      background: var(--芒果黄);
    }

    div {
      /* 白色文字 */
      color: white;

      /* 字体大小 */
      font-size: 30px
    }
  </style>
</head>
<body>
  <div class="top">无论你怎么滑动屏幕，我都是固定不变的</div>
  <div class="main">
    这里是主盒子
    <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
    这里是主盒子
  </div>
  <div class="bottom">无论你怎么滑动屏幕，我都是固定不变的</div>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1216.html)点击 "运行案例" 可查看在线运行效果

运行结果：
![图片描述](http://img.mukewang.com/wiki/5f03ee920a7e714301840330.jpg)



## 3. 去掉主盒子的外边距

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 在这里用link标签引入中文渐变色 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-gradient">
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 令html和body全屏显示 */
    html, body { height: 100% }

    /* 设置父元素为相对定位 */
    body { position: relative; }

    /* 上面的那栏 */
    .top {
      /* 设置为固定定位 */
      position: fixed;

      /* 距离上边左边为0 */
      top: 0;
      left: 0;

      /* 宽度铺满屏幕 */
      width: 100%;

      /* 给个合适的高度 */
      height: 80px;

      /* 绿色背景 */
      background: var(--极光绿);
    }

    .main {
      /* 给个合适的高度 */
      height: 1000px;

      /* 渐变背景 */
      background: var(--灯红酒绿);
    }

    /* 下面的那栏 */
    .bottom {
      /* 设置为固定定位 */
      position: fixed;

      /* 距离下边左边为0 */
      bottom: 0;
      left: 0;

      /* 宽度铺满屏幕 */
      width: 100%;

      /* 给个合适的高度 */
      height: 80px;

      /* 黄色背景 */
      background: var(--芒果黄);
    }

    div {
      /* 白色文字 */
      color: white;

      /* 字体大小 */
      font-size: 30px
    }
  </style>
</head>
<body>
  <div class="top">无论你怎么滑动屏幕，我都是固定不变的</div>
  <div class="main">
    这里是主盒子
    <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
    这里是主盒子
  </div>
  <div class="bottom">无论你怎么滑动屏幕，我都是固定不变的</div>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1217.html)点击 "运行案例" 可查看在线运行效果

运行结果：
![图片描述](http://img.mukewang.com/wiki/5f03ef250ab1372b01840330.jpg)



## 4. 小结

为什么去掉外边距文字就消失了呢？原来，去掉了外边距就相当于把盒子延展到了最顶端和最底端，因为上下两栏使用了固定定位。

固定定位会导致元素脱离默认文档流，也就是说上下两栏不在默认文档流里面占用任何空间，所以上面的文字和下面的文字就会被挡住。

所以我们应该给主盒子一个合适的上下边距，来绕开被挡住的部分。

# 非固定定位实现上下栏布局



## 1. 前言

除了将上下栏固定在屏幕上，我们还有另一种选择，那就是上下栏和主盒子都在屏幕的那个位置不动，那有人可能会说了，主盒子里的内容要是多了，超出了屏幕的高度该怎么办呢？这就要用到一个属性叫做 **overflow-y**：



## 2. 实现

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 在这里用link标签引入中文渐变色 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-gradient">
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 令html和body全屏显示 */
    html, body { height: 100% }

    /* 上面的那栏 */
    .top {
      /* 设置一个合适的高度 */
      height: 10%;

      /* 蓝色背景 */
      background: var(--靛蓝);
    }

    /* 主显示区 */
    .main {
      /* 给个合适的高度 */
      height: 80%;

      /* 给个好看的渐变色 */
      background: var(--天蓝);

      /* 竖直方向的溢出设置为自动 */
      overflow-y: auto;
    }

    /* 下面的那栏 */
    .bottom {
      /* 设置一个合适的高度 */
      height: 10%;

      /* 蓝色背景 */
      background: var(--宝石蓝);
    }

    /* 盒子的默认样式 */
    div {
      font-size: 30px;
      color: white;
    }
  </style>
</head>
<body>
  <div class="top"></div>
  <div class="main">
    这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子这里是主盒子
  </div>
  <div class="bottom"></div>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1218.html)点击 "运行案例" 可查看在线运行效果

运行结果：
![图片描述](http://img.mukewang.com/wiki/5efd88760a75a83a01840330.jpg)
可以看到这个案例虽然文字撑开了内容导致溢出，然后出现滚动条可以上下滚动，但背景色却没有变化，这是因为我们是在主盒子上面加的背景色。
这种靠子元素来撑开内容的溢出应该把样式全部写在子元素上面去，父元素只提供一个高度和一个**overflow-y**即可：

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 在这里用link标签引入中文渐变色 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-gradient">
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 令html和body全屏显示 */
    html, body { height: 100% }

    /* 上面的那栏 */
    .top {
      /* 设置一个合适的高度 */
      height: 10%;

      /* 蓝色背景 */
      background: var(--靛蓝);
    }

    /* 主显示区 */
    .main {
      /* 给个合适的高度 */
      height: 80%;

      /* 竖直方向的溢出设置为自动 */
      overflow-y: auto;
    }

    .child {
      height: 1000px;

      /* 给个好看的渐变色 */
      background: var(--天蓝);
    }

    /* 下面的那栏 */
    .bottom {
      /* 设置一个合适的高度 */
      height: 10%;

      /* 蓝色背景 */
      background: var(--宝石蓝);
    }

    /* 盒子的默认样式 */
    div {
      font-size: 30px;
      color: white;
    }
  </style>
</head>
<body>
  <div class="top"></div>
  <div class="main">
    <div class="child"></div>
  </div>
  <div class="bottom"></div>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1219.html)点击 "运行案例" 可查看在线运行效果

运行结果：
![图片描述](http://img.mukewang.com/wiki/5f041daf0aac3c1901840330.jpg)



## 3. 小结

这里一定要记住这几个要点：

- 上栏和下栏的宽度加起来要刚好是屏幕的高度
- 下栏一定要写**overflow-y: auto**
- 下栏的背景什么的最好写在子元素上，除非你就是想要这种背景不动的效果

# 固定定位+渐隐渐现



## 1. 前言

相信大家也会在手机上见过类似这样的效果：
![图片描述](http://img.mukewang.com/wiki/5f50f9b40a13728402680599.jpg)
注意看布局，眼球不要被那个 `45-70K` 的薪资吸引了哈！
这是某著名招聘网站的页面，如果屏幕前的你正在用这款软件的话，希望你也能找到这么高工资的工作。

当然咱们主要还是来讲布局，注意看上面那栏内的文字是不是随着页面的滚动而有一个渐隐渐现的效果啊。

这样的话不但会在刚进入页面时显得更加的整洁，而且更是丰富了交互的趣味性。



## 2. 实现

这里需要用到一点点的 [JS](https://www.imooc.com/wiki/Javascriptbase) 来获取页面滚动的距离，不会 [JS](https://www.imooc.com/wiki/Javascriptbase) 的同学先不要紧张，看不懂的话可以先记住怎么用：

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 在这里用link标签引入中文渐变色 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-gradient">
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 令html和body全屏显示 */
    html, body { height: 100% }

    /* 上面的那栏 */
    .top {
      /* 设置为固定定位 */
      position: fixed;

      /* 距离上边左边为0 */
      top: 0;
      left: 0;

      /* 宽度铺满屏幕 */
      width: 100%;

      /* 给个合适的高度 */
      height: 80px;

      /* 令其透明 */
      opacity: 0;

      /* 蓝色背景 */
      background: var(--宝石蓝)
    }

    .main {
      /* 给个合适的下边距 */
      margin-bottom: 80px;

      /* 给个合适的高度 */
      height: 1000px;

      /* 渐变背景 */
      background: var(--天蓝)
    }

    /* 下面的那栏 */
    .bottom {
      /* 设置为固定定位 */
      position: fixed;

      /* 距离下边左边为0 */
      bottom: 0;
      left: 0;

      /* 宽度铺满屏幕 */
      width: 100%;

      /* 给个合适的高度 */
      height: 80px;

      /* 蓝色背景 */
      background: var(--靛蓝)
    }
  </style>
</head>
<body>
  <div class="top"></div>
  <div class="main"></div>
  <div class="bottom"></div>

  <script>
    // 获取固定栏
    const dom = document.getElementsByClassName('top')[0]

    window.addEventListener('scroll', _ => {
      // 获取偏移值
      const top = document.documentElement.scrollTop

      // 设置一个合适的范围
      if (top <= 150) {
        // 对opacity作计算，透明度从起始到1随偏移值而改变
        const opacity = top / 150

        // 令上栏的透明度变成计算后的透明度
        dom.style.opacity = opacity
      } else {
        // 在移动一定范围后令其完全不透明
        dom.style.opacity = 1
      }
    })
  </script>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1220.html)点击 "运行案例" 可查看在线运行效果

运行结果：
![图片描述](http://img.mukewang.com/wiki/5f041f760a31eb5d01840330.jpg)

> 这里就不用再给主盒子加上边距啦，因为在最上面的时候上栏完全透明，不会覆盖住内容的。

通过我们对移动端的各种网站的观察发现，通常来说下面那栏是不会渐隐渐现的，所以这里下栏一直是固定的。

如果同学们也想给下栏加入一个炫酷的效果，那就赶快来打开编辑器来改造一下这段代码吧！



## 3. 结语

这一章的上下栏布局和上一章的吕形布局很相似，基本上可以说学会了一个的时候就已经学会了另一个。

不过下一章可就和这一章不那么相似了，因为下一章是每天刷微博逛朋友圈所经常看到的：**九**! **宫**! **格**!

# 九宫格简介



## 1. 前言

有些同学乍一听九宫格可能不知道是什么，但其实它在我们的日常生活中很常见：
![图片描述](http://img.mukewang.com/wiki/5ee1b9b709cfd26003630307.jpg)
顾名思义，九宫格通常为如图这种三行三列的布局。

微信客户端就用到了这种布局方式：
![图片描述](http://img.mukewang.com/wiki/5ee1ba7009a186d704000545.jpg)
大家最熟悉的朋友圈也采用了九宫格：
![图片描述](http://img.mukewang.com/wiki/5ee1baa3094208f104100855.jpg)
还有微博：
![图片描述](http://img.mukewang.com/wiki/5ee1bad70936739004060652.jpg)



## 2. 边框九宫格

九宫格和其他布局有个明显的区别，那就是加入边框后的九宫格有个bug：
![图片描述](http://img.mukewang.com/wiki/5ee1b9b709cfd26003630307.jpg)
大家以为加个边框就变成了上面这样对吧？
实际上却是这样的：
![图片描述](http://img.mukewang.com/wiki/5f05944d09c4968602880283.jpg)
有没有感觉九宫格里面的框框好像更粗一点？

接下来的课程我们就先来讲微博或朋友圈的那种有一定空隙的九宫格，接下来就来好好讲解一下带边框的九宫格以及带边框以后为什么中间会变粗的原理，顺便延伸出一道关于九宫格布局的经典面试题。



## 3. 实现手段

一方面我们可以利用现有的CSS中文库：[chinese-layout](https://www.yuque.com/vue-sharp/oco0rf/ded6m5) 来快速实现九宫格布局：

- [中文布局 CSS 库](http://www.imooc.com/wiki/mobilelayout/chinesenine.html)

> 这种方式不仅利于我们的学习，更加有助于我们的记忆。

然后也会带领大家如何在不依赖于任何外界条件的情况下纯手工实现九宫格布局：

- [网格布局](http://www.imooc.com/wiki/mobilelayout/ninegrid.html)
- [表格布局](http://www.imooc.com/wiki/mobilelayout/tablenine.html)
- [绝对定位](http://www.imooc.com/wiki/mobilelayout/absolute.html)
- [弹性布局](http://www.imooc.com/wiki/mobilelayout/flexnine.html)
- [左浮动法](http://www.imooc.com/wiki/mobilelayout/leftfloat.html)

但除了上面的那些类似于朋友圈或微博的九宫格以外，我们还有另一种九宫格的形式：

- [加入边框](http://www.imooc.com/wiki/mobilelayout/bordernine.html)
- [边框九宫格](http://www.imooc.com/wiki/mobilelayout/nineborder.html)

接下来我们还会对其进行改进：

- [改进版](http://www.imooc.com/wiki/mobilelayout/better.html)

作为扩展阅读，我们还提供了一道用九宫格来实现的经典面试题：

- [经典面试题](http://www.imooc.com/wiki/mobilelayout/question.html)

> 不过由于经典面试题考察的范围很广、不止考察了面试者的 CSS 功底，同样也考察了一些 JS 功底。
> 所以最后这一小节只作为扩展阅读，防止没有 JS 基础的小伙伴看了懵圈。



## 4. 小结

九宫格并不像单列布局、上下栏布局那样的主要布局。

它是一种小型布局，通常集成在主要布局之内。

比如大家前面看到的那些图，九宫格通常都是在单列布局的内部存在的。

# 中文布局CSS库实现九宫格



## 1. 开篇词

据不完全统计（其实就统计了自己身边的朋友和同事），在刨除抖音或快手这一类短视频 APP 后，每天在手机上花费时间最长的就是刷微博和逛朋友圈。

在刷微博和逛朋友圈的时候经常会看到这种东西：

![图片描述](http://img.mukewang.com/wiki/5f04376909d1390e03420342.jpg)
它有一个高大上的名字：九宫格。

它在移动端的运用十分的广泛，而且不仅仅是在移动端的运用，它甚至还运用到了一些面试题中，因为九宫格可以很好的考察面试者的 CSS 功底。

有些同学可能觉得九宫格看上去非常的简单，但实际上一些边框问题却还是很考验人的。

借助市面上已有的 CSS 库，我们可以很轻易的做到九宫格布局，尤其是可以用到中文关键字，这非常有利于我们的记忆，它就是 [chinese-layout](https://www.yuque.com/react-hooks/oco0rf/ded6m5)。

然后我们再用一个中文渐变色的CSS库来美化我们的界面：[chinese-gradient](https://www.yuque.com/react-hooks/xflqsh/yxn4m7)。



## 2. 用法

要点就是在 **head** 标签中用 **link** 标签引入 [chinese-gradient](https://www.yuque.com/react-hooks/xflqsh/yxn4m7) 和 [chinese-layout](https://www.yuque.com/react-hooks/oco0rf/ded6m5) 。
然后就可以使用中文关键字啦：

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 在这里用link标签引入中文布局 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-layout">

  <!-- 在这里用link标签引入中文渐变色 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-gradient">
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0 }
    ul { list-style: none }

    /* 全屏显示 */
    html, body, ul { height: 100% }

    /* 在父元素上写入九宫格 */
    ul {
      display: grid;
      grid: var(--九宫格);
      gap: 5px
    }

    /* 给子元素上色 */
    li {
      background: var(--极光绿)
    }
  </style>
</head>
<body>
  <ul>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
  </ul>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1221.html)点击 "运行案例" 可查看在线运行效果

运行结果：
![图片描述](http://img.mukewang.com/wiki/5f0438f00945d1da03000300.jpg)



## 3. 小结

怎么样？用 CSS 库是不是很简单呢？
但是我们不仅要学会 CSS 库的用法，还要学会在不依赖外部条件的情况下进行纯手写，所以下一小节我们来讲讲原生 CSS 的写法。

# 网格布局实现九宫格布局



## 1. 网格布局

这种几行几列的布局最适合用网格布局来写啦！来看一下语法：

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 在这里用link标签引入中文渐变色 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-gradient">
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 全屏显示 */
    html, body, ul { height: 100% }

    /* 父元素 */
    ul {
      /* 清除默认样式 */
      list-style: none;

      /* 令其用grid方式去显示 */
      display: grid;

      /* 将其切割成三行三列 */
      grid: repeat(3, 1fr) / repeat(3, 1fr);

      /* 设置一个合适的间距 */
      gap: 3px
    }

    /* 子元素 */
    li {
      /* 黄色渐变 */
      background: var(--芒果黄)
    }
  </style>
</head>
<body>
  <ul>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
  </ul>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1222.html)点击 "运行案例" 可查看在线运行效果

运行结果：
![图片描述](http://img.mukewang.com/wiki/5f044b1f094765e703000300.jpg)
由于grid布局较为复杂，一言难尽，所以在这里贴上两个较为流行的grid入门教程地址：

- 阮一峰博客：http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html
- 张鑫旭博客：https://www.zhangxinxu.com/wordpress/2018/11/display-grid-css-css3/

很多人担心Grid的兼容性：
![图片描述](http://img.mukewang.com/wiki/5ee22f9409019aef12020259.jpg)
其实可以看到绝大部分浏览器都已经支持了，即使是最被吐槽的IE浏览器，也可以通过增加-ms-前缀来进行支持,

如：display: -ms-grid;



## 2. 小结

Grid 布局是近些年来逐渐兴起的一种布局方式，它的功能十分强大。

用它可以轻松的实现响应式布局，以前要很多行代码很多行判断的复杂布局，再掌握了 Grid 之后也都不在话下。

当然现在不懂没关系，因为我们接下来还会专门出一门 Grid 布局的教程，敬请期待！

# 表格布局实现九宫格布局



## 1. 表格布局

像这种横平竖直几行几列的布局，除了网格布局以外，表格布局也很合适，来看下语法：

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 在这里用link标签引入中文渐变色 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-gradient">
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 全屏显示 */
    html, body, ul { height: 100% }

    /* 父元素 */
    ul {
      /* 给个合适的宽度 */
      width: 100%;

      /* 清除默认样式 */
      list-style: none;

      /* 令其用table方式去显示 */
      display: table;
 
      /* 设置间距 */
      border-spacing: 3px
    }

    /* 子元素 */
    li {
      /* 令其用table-row方式去显示 */
      display: table-row
    }

    /* 孙子元素 */
    div {
      /* 令其用table-cell方式去显示 */
      display: table-cell;

      /* 蓝色渐变 */
      background: var(--湖蓝)
    }
  </style>
</head>
<body>
  <ul>
    <li>
      <div></div>
      <div></div>
      <div></div>
    </li>
    <li>
      <div></div>
      <div></div>
      <div></div>
    </li>
    <li>
      <div></div>
      <div></div>
      <div></div>
    </li>
  </ul>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1229.html)点击 "运行案例" 可查看在线运行效果

运行结果：
![图片描述](http://img.mukewang.com/wiki/5f0569de09de280903000300.jpg)
可以看到在 DOM 结构上我们并没有用到 <table>、<tr>、<td> 这类传统表格元素，因为在这种情况下只是用到了表格的那种几行几列而已，但实际上九宫格并不是表格，所以为了符合 W3C 的语义化标准，我们采用了其他的 DOM 元素。



## 2. 小结

在有些适合使用表格布局但又不是表格的情况下，可以利用 **display** 属性来模仿表格的行为：

- **display: table;** 相当于把元素的行为变成 ****；
- **display: inline-table;** 相当于把元素的行为变成行内元素版的 ****；
- **display: table-header-group;** 相当于把元素的行为变成 ；
- **display: table-row-group;** 相当于把元素的行为变成 ；
- **display: table-footer-group;** 相当于把元素的行为变成 ；
- **display: table-row;** 相当于把元素的行为变成 ；
- **display: table-column-group;** 相当于把元素的行为变成 ；
- **display: table-column;** 相当于把元素的行为变成 ；
- **display: table-cell;** 相当于把元素的行为变成 .；
- **display: table-caption;** 相当于把元素的行为变成 。

# 绝对定位实现九宫格布局



## 1. 绝对定位

通过对九宫格的观察可以发现，每个格子都是固定在每隔三分之一的那么一个位置，这种规律性导致可以使用绝对定位来实现九宫格：

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 在这里用link标签引入中文渐变色 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-gradient">
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 全屏显示 */
    html, body, ul { height: 100% }

    /* 父元素 */
    ul {
      /* 清除默认样式 */
      list-style: none
    }

    /* 子元素 */
    li {
      /* 绝对定位 */
      position: absolute;

      /* 宽高都是33% */
      width: 33%;
      height: 33%;

      /* 红色渐变 */
      background: var(--火红)
    }

    /* 第一个子元素 */
    li:first-child {
      top: 0;
      left: 0;
    }

    /* 第二个子元素 */
    li:nth-child(2) {
      top: 0;
      left: 33.33%;
    }

    /* 第三个子元素 */
    li:nth-child(3) {
      top: 0;
      left: 66.66%;
    }

    /* 第四个子元素 */
    li:nth-child(4) {
      top: 33.33%;
      left: 0;
    }

    /* 第五个子元素 */
    li:nth-child(5) {
      top: 33.33%;
      left: 33.33%;
    }

    /* 第六个子元素 */
    li:nth-child(6) {
      top: 33.33%;
      left: 66.66%;
    }

    /* 第七个子元素 */
    li:nth-child(7) {
      top: 66.66%;
      left: 0;
    }

    /* 第八个子元素 */
    li:nth-child(8) {
      top: 66.66%;
      left: 33.33%;
    }

    /* 第九个子元素 */
    li:last-child {
      top: 66.66%;
      left: 66.66%;
    }
  </style>
</head>
<body>
  <ul>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
  </ul>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1230.html)点击 "运行案例" 可查看在线运行效果

运行结果：
![图片描述](http://img.mukewang.com/wiki/5f0572e50952a8f203000300.jpg)



## 2. 小结

绝对定位的缺点就是相对于其他方式显得较为繁琐，而且间距不能靠某个属性来控制，而是靠改变宽高和位置来控制间距，下一小节我们来讲一下如何用弹性盒子去实现九宫格布局。

# 弹性布局实现九宫格布局



## 1. 弹性布局

弹性布局已经成为移动端最流行的布局方式之一了，还不了解的同学赶快去了解一下吧！

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 在这里用link标签引入中文渐变色 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-gradient">
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 全屏显示 */
    html, body, ul { height: 100% }

    /* 父元素 */
    ul {
      /* 清除默认样式 */
      list-style: none;

      /* 显示为弹性布局 */
      display: flex;

      /* 允许换行 */
      flex-flow: wrap;
    }

    /* 子元素 */
    li {
      /* 宽高都是百分之33*/
      width: 33%;
      height: 33%;

      /* 给个合适的外边距 */
      margin: .5px;

      /* 深蓝渐变 */
      background: var(--黛蓝)
    }
  </style>
</head>
<body>
  <ul>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
  </ul>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1231.html)点击 "运行案例" 可查看在线运行效果

运行结果：
![图片描述](http://img.mukewang.com/wiki/5f058af909b0c4e603000300.jpg)



## 2. 小结

在 flex 九宫格这个案例中，有一个很重要的要点就是要让弹性盒子换行（默认是不换行的），如果很多同学都对 flex 这种布局方式感到疑惑的话，慕课网会考虑单独出一门 flex 布局的入门课程，敬请期待吧！

# 左浮动实现九格宫布局



## 1. 左浮动法

浮动是较为经典的布局属性：

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 在这里用link标签引入中文渐变色 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-gradient">
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 全屏显示 */
    html, body, ul { height: 100% }

    /* 父元素 */
    ul {
      /* 清除默认样式 */
      list-style: none;
    }

    /* 伪元素 */
    ul::after {
      /* 显示为块级元素 */
      display: block;

      /* 内容为空 */
      content: '';

      /* 清除浮动 */
      clear: both;
    }

    /* 子元素 */
    li {
      /* 宽高都是百分之33*/
      width: 33%;
      height: 33%;

      /* 左浮动 */
      float: left;

      /* 给个合适的外边距 */
      margin: .5px;

      /* 粉红渐变 */
      background: var(--怦然心动)
    }
  </style>
</head>
<body>
  <ul>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
  </ul>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1232.html)点击 "运行案例" 可查看在线运行效果

运行结果：
![图片描述](http://img.mukewang.com/wiki/5f0590fd09e1f15603000300.jpg)



## 2. 小结

在当年那个刀耕火种的年代，想要让块级元素进行换行，一般都是靠 **float** 这个属性。
但前面讲了这么多种方式都是靠的边距来区分每个盒子，但如果不加任何边距只靠边框会变成什么样子呢？想知道的话就赶快翻到下一小节吧！

# 加入边框



## 1. 前言

不带边框和带边框的九宫格实现起来有着较大的不同，这是为什么呢？
比如先给大家看一个无边框的九宫格：
![图片描述](http://img.mukewang.com/wiki/5f0593cb0909383502880295.jpg)
通常来说没有边框的九宫格都是有一个间距，比如说朋友圈的那种：
![图片描述](http://img.mukewang.com/wiki/5f0593dc09b094d902780277.jpg)
如果给它加个边框就会变成这样：
![图片描述](http://img.mukewang.com/wiki/5f0593ed096cff8f02880295.jpg)
看起来还是没毛病对吧？那接下来我们把它们九个合并到一起去再看看：
![图片描述](http://img.mukewang.com/wiki/5f0593fe096bb3f302880283.jpg)



## 2. 详细对比

有没有感觉好像哪里不太对？如果感觉不太明显的话我们将灰色背景去掉再来瞅一眼：
![图片描述](http://img.mukewang.com/wiki/5f05944d09c4968602880283.jpg)
是不是感觉格子里面的线条好像更粗呢？为什么会造成这种现象，其实是因为这样：
![图片描述](http://img.mukewang.com/wiki/5f0594650a39543702780273.jpg)
相邻的两个边框贴在了一起就会变成两倍粗的一个大边框。



## 3. 小结

之前我们都是用外边距等属性来让九宫格之间有间距的，但还是有一些场景是不需要间距而需要边框的，比如说微信的这个界面：
![图片描述](http://img.mukewang.com/wiki/5ee1ba7009a186d704000545.jpg)
或者这种：
![图片描述](http://img.mukewang.com/wiki/5ee1b9b709cfd26003630307.jpg)
可以看到他们的各个边框都很均匀，没有出现哪粗哪细的情况，接下来我们就来讲一下如何才能做到这一点。

# 边框九宫格



## 1. 前言

由于实现九宫格最方便的方式就是网格布局，所以边框九宫格咱们来拿网格实现法举例，边框九宫格的关键点其实并不在于用哪种方式实现九宫格，所以很容易融会贯通。



## 2. 笨方法

相信大家都有过这样的经历(*假装你们有过*)：有一道数学题你并不会，但是你却想到了一个耿直的办法来解开这道数学题，答案都是正确的，只不过过程曲折了些：

比如问你**6 x 9 = ？** 突然你就忘记了九九乘法表，但是你知道**6 x 9 = 9 + 9 + 9 + 9 + 9 + 9**。
于是乎你就算呗，最后终于算出来了，顶多麻烦了点，但依然得出了正确答案不是吗？(*即使会被数学老师diss一番*)

边框九宫格也是同理，咱们不懂怎么让两个边框并在一起的时候怎么变细，但是咱们可以用笨方法：
让两个相邻的盒子的其中一个的相邻边不显示边框不就完了！
![图片描述](http://img.mukewang.com/wiki/5f05af480964b40c03000300.jpg)
这样的边框合在一起就不会出现两个边框贴在一起啦！
思路有了，那咱们再来个动态程序看一眼：

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 在这里用link标签引入中文渐变色 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-gradient">
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 全屏显示 */
    html, body, ul { height: 100% }

    /* 父元素 */
    ul {
      /* 清除默认样式 */
      list-style: none;

      /* 显示为网格布局 */
      display: grid;

      /* 均分成三行三列 */
      grid: repeat(3, 1fr) / repeat(3, 1fr);

      /* 给个合适的间距 */
      gap: 20px;

      /* 调用动画 */
      animation: clear-gap 5s ease-out infinite alternate
    }

    /* 子元素 */
    li {
      /* 两像素的边框 */
      border: 2px solid black
    }

    /* 定义动画 */
    @keyframes clear-gap { to { gap: 0 } }

    /* 第一个子元素 */
    li:first-child {
      border-right: none;
      border-bottom: none;
    }

    /* 第二个子元素 */
    li:nth-child(2) {
      border-bottom: none;
    }

    /* 第三个子元素 */
    li:nth-child(3) {
      border-left: none;
      border-bottom: none;
    }

    /* 第四个子元素 */
    li:nth-child(4) {
      border-right: none;
    }

    /* 第六个子元素 */
    li:nth-child(6) {
      border-left: none;
    }

    /* 第七个子元素 */
    li:nth-child(7) {
      border-top: none;
      border-right: none;
    }

    /* 第八个子元素 */
    li:nth-child(8) {
      border-top: none;
    }

    /* 第九个子元素 */
    li:last-child {
      border-top: none;
      border-left: none;
    }
  </style>
</head>
<body>
  <ul>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
  </ul>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1233.html)点击 "运行案例" 可查看在线运行效果

运行结果：





## 3. 小结

这么做完全可以实现，绝对没毛病，但一般来说大家用笨方法解出来的数学题，即使答案正确，老师也不会给满分，因为 **6 x 9 = ？** 就是想考察你的乘法水平，但你却用了加法，虽然答案一样但却饶了许多弯路。如果去参加面试的时候这么实现出来，面试官也不会给你满分，那么下一小节我们来看看有没有不那么麻烦的方法。

# 改进版



## 1. 前言

笨方法的缺陷就是要算出每个盒子应该应用的边框，而且在写法上也很麻烦，要为每个盒子定义不同的边框。并且计算出来的结果只适用于九宫格，如果换成四宫格或者十二宫格的话又要为每个盒子重新定义一下边框的样式了。
那么有没有一种方法是给子元素一个统一的样式就可以做到一样的样式呢？答案必须是肯定的！



## 2. 不那么笨的方法

不知道同学们有没有想过，下面这种边框的样式几乎是每个盒子的边框都不太一样：
![图片描述](http://img.mukewang.com/wiki/5f05af480964b40c03000300.jpg)
所以写起来会很麻烦，那什么形状的边框能做到只给所有的子盒子都定义一样的边框样式就可以的呢？答案就是：
![图片描述](http://img.mukewang.com/wiki/5f0c0c0709de833603000300.jpg)
但是仔细一看经不起推敲啊：整个九宫格最右边和最下边的边框都没有了！其实只要咱们在父元素上再加上右侧和下侧的边框即可：
![图片描述](http://img.mukewang.com/wiki/5f0c0c61092c3bd003000300.jpg)
而且并不一定非得是这个方向的，别的方向也可以实现啊，比如酱婶儿的：
![图片描述](http://img.mukewang.com/wiki/5f0c0d4009fb768a03000300.jpg)
酱婶儿的：
![图片描述](http://img.mukewang.com/wiki/5f0c0d63097f70cd03000300.jpg)
还有酱婶儿的：
![图片描述](http://img.mukewang.com/wiki/5f0c0d890938fd9703000300.jpg)
将他们都合并到一起去就会变成酱婶儿的：

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 在这里用link标签引入中文渐变色 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-gradient">
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 全屏显示 */
    html, body, ul { height: 100% }

    /* 父元素 */
    ul {
      /* 清除默认样式 */
      list-style: none;

      /* 显示为网格布局 */
      display: grid;

      /* 均分成三行三列 */
      grid: repeat(3, 1fr) / repeat(3, 1fr);

      /* 给个合适的间距 */
      gap: 20px;

      /* 添加右下方内边距 */
      padding-right: 20px;
      padding-bottom: 20px;

      /* 设置盒模型 */
      box-sizing: border-box;

      /* 两像素的右下角边框 */
      border-right: 2px solid black;
      border-bottom: 2px solid black;

      /* 调用动画 */
      animation: clear-gap 5s ease-out infinite alternate
    }

    /* 子元素 */
    li {
      /* 两像素的左上角边框 */
      border-top: 2px solid black;
      border-left: 2px solid black;
    }

    /* 定义动画 */
    @keyframes clear-gap {
      to { gap: 0; padding: 0 }
    }
  </style>
</head>
<body>
  <ul>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
  </ul>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1242.html)点击 "运行案例" 可查看在线运行效果

运行结果：





## 3. 小结

那么这种方案就是最优解了吗？下一小节我们来看一道经典面试题是如何通过九宫格来考验面试者的CSS功底的，然后再看看正确答案是怎么解决九宫格的边框问题的。

# 九宫格经典面试题



## 1. 前言

其实面试有时候并不像大家想象的那样问一些很基础的问题，比如：

- 请谈一下你对CSS盒模型的理解
- 你对flex布局了解的怎么样
- 了解过grid布局吗
- 当元素的外边距为负值时会有什么样的行为
- 当元素重叠在一起时如何控制上下层级
- 如何水平垂直居中
- 什么是事件冒泡
- 怎么控制特定位置的元素样式(比如偶数位置的样式)
- 如何判断事件是从哪个元素冒泡过来的
- 哪个CSS属性值可以减少重复定义颜色值

这样问的话效率会比较低，而优秀的面试题只需要一道，就可以考察上述所有的这些问题。



## 2. 面试题

即使候选者对上面这些问题全部都对答如流，也不一定能够灵活的运用这些知识。
而这道面试题不仅考察了候选人的基础，更考察了候选者对基础知识的灵活运用，来看看这道面试题：

（鼠标点击可以互动）

要求如下：

- 边框九宫格的每个格子中的数字都要居中
- 鼠标经过时边框和数字都要变红
- 格子中的数字居中用flex实现
- 点击九宫格会弹出对应的数字

具体实现如下：

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0; }

    /* 全屏显示 */
    html, body { height: 100% }

    body {
      /* 网格布局 */
      display: grid;

      /* 子元素居中 */
      place-items: center;
    }

    /* 父元素 */
    ul {
      width: 300px;
      
      /* 清除默认样式 */
      list-style: none;

      /* 设置为flex布局 */
      display: flex;

      /* 设置换行 */
      flex-flow: wrap;
    }

    /* 子元素 */
    li {
      /* 显示为网格布局 */
      display: grid;

      /* 子元素水平垂直居中 */
      place-items: center;

      /* 宽高都是100像素 */
      width: 100px;
      height: 100px;

      /* 设置盒模型 */
      box-sizing: border-box;

      /* 设置两像素的边框 */
      border: 2px solid black;

      /* 负边距 */
      margin: -2px 0 0 -2px;
    }

    /* 第1、4、7个子元素 */
    li:nth-child(3n+1) {
      /* 取消左负边距 */
      margin-left: 0
    }

    /* 前三个子元素 */
    li:first-child, li:nth-child(2), li:nth-child(3) {
      /* 取消上负边距 */
      margin-top: 0
    }

    /* 当鼠标经过时 */
    li:hover {
      /* 红色字体 */
      color: red;

      /* 红色边框 */
      border: 2px solid;

      /* 调高层级 */
      z-index: 1;
    }
  </style>
</head>
<body>
  <ul>
    <li>1</li>
    <li>2</li>
    <li>3</li>
    <li>4</li>
    <li>5</li>
    <li>6</li>
    <li>7</li>
    <li>8</li>
    <li>9</li>
  </ul>
  <script>
    // 选择ul元素
    const ul = document.getElementsByTagName('ul')[0]

    // 监听ul元素的点击事件
    ul.addEventListener('click', e => alert(e.target.innerText))
  </script>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1243.html)点击 "运行案例" 可查看在线运行效果



## 3. 面试题都考察了哪些上述知识呢



### 负边距：

```css
li {
	margin: -2px 0 0 -2px;
}
 
```

- 利用负边距可以消除边框粗的bug



### flex

```css
ul {
	/* 设置为flex布局 */
    display: flex;

    /* 设置换行 */
    flex-flow: wrap;
} 
 
```



### grid布局、水平垂直居中

```css
li {
	  /* 网格布局 */
	  display: grid;

	  /* 子元素居中 */
	  place-items: center;
}
 
```



### 减少重复定义颜色值

```css
li:hover {
      /* 红色字体 */
      color: red;

      /* 红色边框 */
      border: 2px solid;
}
 
```

可以看到定义红色边框的时候并没有写红色(*red或#f00*)，那是因为如果你不写的话，默认是**currentColor**，这个关键字代表的就是你当前的**color**值。
有些同学可能会觉得纳闷：这单词这么长，还不如直接写个red多方便啊，其实这个单词相当于一个变量，指向**color**值，而别忘了**color**是可以继承的！
如果在一个外层元素中定义了一个颜色，里面的子元素都可以继承，用**JS**来控制的话只需要获取外层DOM元素然后修改它的**color**样式即可，currentColor能做的事情很多，这里为了不跑题就先不展开讲，有兴趣的同学可以去搜一下。



### CSS盒模型

```css
li {
	/* 设置盒模型 */
    box-sizing: border-box;
}
 
```

如果不写这个属性的话，每个格子的边框也会计算在内，最终会超过父元素的三分之一，导致提前换行。
大家可以在案例中去掉这个属性，感受一下没有了它会发生什么样的后果。



### 上下层级

```css
li:hover {
	z-index: 1;
}
 
```

如果没有这个属性，在鼠标经过时边框的样式会产生错乱。



### 特定位置的元素样式

```css
/* 第1、4、7个子元素 */
li:nth-child(3n+1) {
	xxx: xxx;
}

/* 前三个子元素 */
li:first-child, li:nth-child(2), li:nth-child(3) {
  xxx: xxx;
}
 
```



### 事件冒泡

```js
// 监听ul元素的点击事件
ul.addEventListener('click', e => alert(e.target.innerText))
 
```



## 4. 小结

怎么样，没想到就这一道九宫格居然能考察出这么多的基础知识吧？
同学们课下一定要好好练习一下这道题，亲自动手敲一遍代码，看看能不能在不参照案例代码的情况实现这个功能。

# 响应式简介



## 1. 前言

![图片描述](http://img.mukewang.com/wiki/5f042a310ac4e4da15680371.jpg)
响应式就是一个网站能够兼容多个终端，而不是为每个终端做一个特定的版本，这个概念是为解决移动互联网浏览而诞生的。

无论你的屏幕多大，小一点的屏幕(手机)可以一行行的排列，中等一点的屏幕(平板电脑)可以两列三列的那么排布，更大的屏幕(PC电脑)则可以展示更多的列，因为电脑屏幕的宽高比恰巧与手机相反嘛(宽比高大)。



## 2. 响应式布局

响应式布局通常分为三种：

- 一种是利用弹性盒子Flex、网格布局Grid或左浮动法Float等 CSS 属性来实现的在一列上根据屏幕大小的不同而进行自动换行。
- 另一种是利用媒体查询来根据当前屏幕大小来运行相应的 CSS 代码。
- 还有一种是利用 JavaScript 来获取窗口宽高来动态操作 DOM 元素。

本章我们将重点讲解前两种，因为《移动端布局》这门课是从《CSS 布局》这门课程中拆分出来的，所以能不用 JavaScript 就尽量不用 JavaScript。

> 由于渐隐渐现那两小节必须要获取到屏幕滚动的位置才可以做得到
> 而且不想让同学们错过比较常见的这么一种需求
> 所以才不得已的用到了一点点的 JavaScript



## 3. 小结

响应式布局非常适合那种想要在各种不同设备上都能够流畅显示的网站。

> 响应式的使命就是：一套代码 四处运行

# 中文布局CSS库



## 1. 什么是响应式布局

由于移动端设备尺寸差距非常大，有还在用好几年前手机的、有用高分辨率视网膜屏幕的、还有用屏幕超大的iPad的。

有人可能会问：iPad也算移动端吗？其实并不是只有那种能装进兜里的才叫移动端，虽然说iPad或者其他一些平板电脑不会像手机那样被人随身携带，但下班回家或者放学回宿舍的时候，靠在沙发上拿出平板连上wifi，打开空调再来一杯果汁，是一天当中最幸福的时刻。

平板电脑处于这么一个尴尬的位置：屏幕比不上笔记本、便携又比不过手机，但它毕竟是靠触摸来操作的，虽然也有外接键盘的功能，但大部分还是靠触摸来进行操作的。

既然要靠触摸进行操作，常规的针对PC端写的网站就不太合适了，还是要为移动端写的网站比较靠谱。

但如果设计移动端的时候并没有考虑到这么宽的屏幕，放在平板上就会变成这样：
![图片描述](http://img.mukewang.com/wiki/5f0eea320a9d2f0c06920220.jpg)
也就是说屏幕过小时会被压缩，而屏幕过大时又会被拉伸，响应式就是为了解决这一一种问题的：
![图片描述](http://img.mukewang.com/wiki/5f0ee7600acce5c506920220.jpg)
当然上图这个做的也不是特别的好，因为在拉伸的时候右侧会有空白区域，显得没有填满，真正好的应该是这样：
![图片描述](http://img.mukewang.com/wiki/5f0fdc360a8fa8fa06330339.jpg)
无论屏幕宽窄，左右两侧始终没有缝隙，然后可以根据屏幕的大小来自动进行换行。



## 2. 中文库

借助市面上已有的 CSS 库，我们可以很轻易的做到居中布局，尤其是可以用到中文关键字，这非常有利于我们的记忆，它就是 [chinese-layout](https://www.yuque.com/react-hooks/oco0rf/ded6m5)。

然后我们再用一个中文渐变色的 CSS 库来美化我们的界面：[chinese-gradient](https://www.yuque.com/react-hooks/xflqsh/yxn4m7)

要点就是在**head**标签中用**link**标签引入 [chinese-gradient](https://www.yuque.com/react-hooks/xflqsh/yxn4m7) 和 [chinese-layout](https://www.yuque.com/react-hooks/oco0rf/ded6m5)。
然后就可以使用中文关键字啦：

实例演示

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 在这里用link标签引入中文布局 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-layout">

  <!-- 在这里用link标签引入中文渐变色 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-gradient">
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0 }

    /* 令html和body全屏显示 */
    html, body { height: 100% }

    /* 父元素 */
    ul {
      /* 清除默认样式 */
      list-style: none;

      /* 先在父元素上设置grid布局 */
      display: grid;
      grid: var(--响应式);

      /* 给个合适的间距 */
      gap: 5px
    }

    /* 子元素 */
    li {
      /* 绿色渐变 */
      background: var(--极光绿);

      /* 给个高度 */
      height: 100px
    }
  </style>
</head>
<body>
  <ul>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
  </ul>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1250.html)点击 "运行案例" 可查看在线运行效果

运行结果：
![图片描述](http://img.mukewang.com/wiki/5f0fdc360a8fa8fa06330339.jpg)



## 3. 小结

怎么样？用CSS库是不是很简单呢？
但是我们不仅要学会CSS库的用法，还要学会在不依赖外部条件的情况下进行纯手写，所以下一小节我们来讲讲原生CSS的写法。

# 网格布局



# 1. 前言

在响应式布局这一领域内，grid 布局简直有着当仁不让的天生优势，即使是[chinese-layout](https://www.yuque.com/fancy-components/oco0rf/ded6m5)的底层也依赖的是 grid 布局，grid 可在短短几行代码之中就快速实现出各种布局。
当然，各种布局肯定也包括响应式，不过由于 grid 布局较为复杂，一言难尽，所以在这里贴上两个较为流行的 grid 入门教程地址：

- 阮一峰博客：http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html
- 张鑫旭博客：https://www.zhangxinxu.com/wordpress/2018/11/display-grid-css-css3/

很多人担心Grid的兼容性：
![图片描述](http://img.mukewang.com/wiki/5ee22f9409019aef12020259.jpg)
其实可以看到绝大部分浏览器都已经支持了，即使是最被吐槽的IE浏览器，也可以通过增加-ms-前缀来进行支持,

如：display: -ms-grid;



# 2. 实现

来看一下代码怎么写：

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 在这里用link标签引入中文渐变色 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-gradient">
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0 }

    /* 父元素 */
    ul {
      /* 清除默认样式 */
      list-style: none;

      /* 显示为grid */
      display: grid;

      /* 自动添加行数 列数自动填充 每列不低于100px */
      grid: auto-flow auto / repeat(auto-fit, minmax(100px, 1fr));

      /* 5px的间距 */
      gap: 5px
    }

    /* 子元素 */
    li {
      /* 100px的高度 */
      height: 100px;

      /* 绿色渐变 */
      background: var(--极光绿)
    }
  </style>
</head>
<body>
  <ul>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
  </ul>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1287.html)点击 "运行案例" 可查看在线运行效果

运行结果：
![图片描述](http://img.mukewang.com/wiki/5f0fdc360a8fa8fa06330339.jpg)



# 3. 小结

Grid 布局是近些年来逐渐兴起的一种布局方式，它的功能十分强大。

用它可以轻松的实现响应式布局，以前要很多行代码很多行判断的复杂布局，再掌握了Grid之后也都不在话下。

当然现在不懂没关系，因为我们接下来还会专门出一门 Grid 布局的教程，敬请期待！

# 弹性布局



## 1. flex

除了Grid布局外，Flex也很擅长这件事:

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 在这里用link标签引入中文渐变色 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-gradient">
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0 }
    li { list-style: none }

    /* 父元素 */
    ul {
      /* 显示为flex布局 */
      display: flex;

      /* 允许换行 */
      flex-flow: wrap;
    }

    /* 子元素 */
    li {

      /* 2px的外边距 */
      margin: 2px;

      /* 墨色渐变 */
      background: var(--墨色);
      
      /* 100px的高度 */
      height: 100px;

      /* 令其可伸展 */
      flex: 1;

      /* 100px的宽 */
      flex-basis: 100px
    }
  </style>
</head>
<body>
  <ul>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
  </ul>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1288.html)点击 "运行案例" 可查看在线运行效果

运行结果：
![图片描述](http://img.mukewang.com/wiki/5f226ca80a09c5d404050102.jpg)
注意点：

- **flex: 1;** 一定要写在**flex-basis**之前，不然的话就会变成这样：

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 在这里用link标签引入中文渐变色 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-gradient">
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0 }
    li { list-style: none }

    /* 父元素 */
    ul {
      /* 显示为flex布局 */
      display: flex;

      /* 允许换行 */
      flex-flow: wrap;
    }

    /* 子元素 */
    li {
      /* 2px的外边距 */
      margin: 2px;

      /* 墨色渐变 */
      background: var(--墨色);
      
      /* 100px的高度 */
      height: 100px;

      /* 100px的宽 */
      flex-basis: 100px;

      /* 令其可伸展 */
      flex: 1
    }
  </style>
</head>
<body>
  <ul>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
  </ul>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1336.html)点击 "运行案例" 可查看在线运行效果

运行结果：
![图片描述](http://img.mukewang.com/wiki/5f226df80a789e9805840071.jpg)



## 2. 小结

flex也可以实现响应式，但效果又与grid实现的效果有所不同。
这两种效果都较为常用，大家可以根据自己的项目需求灵活选择不同的方式去实现。

# 左浮动法



## 1. 前言

如果项目要求必须兼容低版本浏览器的话，flex和grid可能都不能用了，只能用CSS2的语法来实现了。
这种情况下float是一个非常好的选择，来看一下具体怎么实现。



## 2. 左浮动

实例演示

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 在这里用link标签引入中文渐变色 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chinese-gradient">
  <style>
    /* 清除默认样式 */
    * { padding: 0; margin: 0 }
    ul { list-style: none }


    /* 子元素 */
    li {
      /* 100px的宽高 */
      width: 100px;
      height: 100px;

      /* 紫红渐变 */
      background: var(--紫红);

      /* 左浮动 */
      float: left;

      /* 2px的外边距 */
      margin: 2px
    }

    /* 清除浮动 */
    ul::after {
      content: '';
      display: block;
      clear: both
    }
  </style>
</head>
<body>
  <ul>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
  </ul>
</body>
</html>
 
```

[运行案例](http://www.imooc.com/wiki/run/1346.html)点击 "运行案例" 可查看在线运行效果

运行结果：
![图片描述](http://img.mukewang.com/wiki/5f22787b0a93615905430233.jpg)



## 3. 小结

除了宽度变化导致换行之外，还有那种宽度变化导致布局变化的响应式，下一节我们就来讲解一下媒体查询。

# 媒体查询



## 1. 前言

其实响应式并不仅仅是屏幕窄了就换行，屏幕宽了就填充这么简单。
有很多时候是需要根据设备的不同来显示不同的布局结构，比如在手机屏幕上用单列布局刚刚好，但是这个网址被台式机访问的话单列就会显得过于宽，这时就要根据不同的设备来运行不同的代码，那么怎么才能知道当前的设备呢？这就是本节我们要讲到的媒体查询。



## 2. 什么是媒体查询

- **媒体：** 就是当前使用的各种设备(*移动设备、固定设备等*)
- **查询：** 通过查询当前属于何种设备以运行不同的代码

如果问大家媒体一般都指的哪些设备，大多数人都会回答：手机、平板、笔记本和台式机这四种。
但其实这四种在媒体查询的眼里只算一种设备，是不是觉得有些不可思议，那还能有什么别的设备呢？
那咱们就来罗列一下媒体查询的所有设备给大家看一眼：

| 媒体类型   | 含义                                                         |
| :--------- | :----------------------------------------------------------- |
| all        | 所有设备                                                     |
| aural      | (*废弃*) 用于语音和声音合成器                                |
| braille    | (*废弃*) 应用于盲文触摸式反馈设备                            |
| embossed   | (*废弃*) 用于打印的盲人印刷设备                              |
| handheld   | (*废弃*) 用于掌上设备或更小的装置，如PDA和小型电话           |
| print      | 用于打印机和打印预览                                         |
| projection | (*废弃*) 用于投影设备                                        |
| screen     | 用于电脑屏幕、平板电脑、智能手机等                           |
| speech     | 应用于屏幕阅读器等发声设备                                   |
| tty        | (*废弃*) 用于固定的字符网格，如电报、终端设备和对字符有限制的便携设备 |
| tv         | (*废弃*) 用于电视和网络电视                                  |

乍一看是不是有点晕？这么多属性……不过，咱们要好好感谢一下科技的进步，随着科技的飞速发展，许多设备现在都淘汰了：像以前的BB机、传呼机、掌上电脑之类的……（*知道这些设备的都暴露年龄了*）
所以，咱们再来看一眼现在还没废弃的设备表：

| 设备   | 中文含义                           |
| :----- | :--------------------------------- |
| all    | 所有设备                           |
| print  | 用于打印机和打印预览               |
| screen | 用于电脑屏幕、平板电脑、智能手机等 |
| speech | 应用于屏幕阅读器等发声设备         |

这次看起来是不是清爽了许多？除了那个all代表所有设备，其他的就只剩仨了：

- **screen：** 这是我们最常用的那些带屏幕的设备
- **print：** 网页其实也是可以通过打印机来打印出来的
- **speech：** 这个不是很常用，除非是那种专门做屏幕自动阅读网站的公司



## 3. screen

我们日常所见到的那些网页，都是通过屏幕来显示出来的，在媒体查询这里并没有什么手机、平板、笔记本之分，它会把它们通通归类为屏幕设备。
那么怎么才能区分屏幕设备到底是手机、平板、笔记本还是台式机呢？这就是下一小节要说到的媒体功能啦。
利用媒体功能来判断宽度，就能猜出来用户用的大概是个什么设备，然后根据设备的不同来显示不同的样式。



## 4. print

但是有时候我想打印一个网页，比如你觉得这节教程写的非常棒，但是内容太多了一下子记不住，打算把它打印在纸上没事的时候就看看，打印出来以后你就会发现有这几个问题：

1. 样式有可能会乱
2. 打印出来很多没用的内容
3. 打印用了很多张纸

因为纸张的大小一般就是A4，和电脑屏幕的比例可不一样，在电脑上看着正常的样式，换个比例可能就会乱。
在电脑上有意义的东西可能在纸上就没意义了，比如那些按钮，点击返回上一页什么的，在电脑上可以点，在纸上就变成了一个占地儿的摆设。

用户真正在意的，也就是那些想打印在纸上的这些文字内容，所以需要用 **print** 来检测是否为打印设备，是的话就不显示那些按钮啊、广告啊、视频啊等等那类的样式了，重点突出的是想打印在纸上的内容。



## 5. speech

有时候想听个小说，当然现在专门有那种听小说的网站，像什么喜马拉雅之类的，可以直接听真人读出来的录音，所以这个不常用。
但假如用朗读软件读取屏幕上内容的时候，你应该不想听到：首页、登陆、注册、返回等这些没必要读出来的字眼…

用这个可以屏蔽掉那些没有必要读出来的内容。



## 6. 小结

本节我们主要介绍了：

- 什么是媒体查询
- 媒体查询都有哪些种类
- screen 的含义
- print 的含义
- speech 的含义

那么下一小节我们就来讲一下媒体功能。

# 媒体属性



## 1. 前言

上一小节我们带领大家认识了一下媒体查询的一些小知识，知道了媒体查询都有哪些设备。

那么问题来了，手机、平板、笔记本和台式机它们几个通通被归为了一类设备：**屏幕设备**(*screen*)，在区分别打印设备还是屏幕设备的时候非常好区分，但如果区分移动端还是PC端的时候要怎么做呢？



## 2. 媒体属性

虽然无论手机、平板、笔记本还是台式机都会被归为**屏幕设备**(*screen*)，但即使是同一种设备也会拥有自己的一套属性，比如宽啊、高啊什么的，我们就可以利用这些属性来判断用户到底是哪一种屏幕设备：

| 媒体属性   | 含义             |
| :--------- | :--------------- |
| max-width  | 浏览器的最大宽度 |
| min-width  | 浏览器的最小宽度 |
| max-height | 浏览器的最大高度 |
| min-height | 浏览器的最小高度 |

为了方便大家的学习，我只挑了这四个最常用的，其实完整版还有很多很多…

但掌握这四个就以及足以应对日常开发的需求了，而且这四个看似不太好理解，实际上咱们一讲大家就能明白：

- max-width: 最大宽度就相当于 **≤** （*宽度小于等于*）
- min-width: 最小宽度就相当于 **≥**（*宽度大于等于*）
- max-height: 最大高度就相当于 **≤**（*高度小于等于*）
- min-height: 最小高度就相当于 **≥**（*高度大于等于*）

而且后面那俩最大、最小高度什么的很少会用到，实际上我们就是靠宽度来检测用户使用的是哪种屏幕设备的。

也就是说你只需要记住这俩就行了：

- max-width: 最大宽度就相当于 **≤** （*宽度小于等于*）
- min-width: 最小宽度就相当于 **≥**（*宽度大于等于*）



## 3. 分辨率

那么什么是最大、最小宽度呢？我们可以拿手机和电脑来举例，假如你手中目前正在用一台 iPhone X 来观看这个网页，那么 iPhone X 的分辨率是 375 x 812 。

有些同学看到这里可能会说：老师你是不是没用过 iPhone ？iPhone 怎么可能就这点分辨率呢？好歹也是大名鼎鼎的视网膜屏幕，人家官网上明明写的就是 iPhone X 为 2436 x 1125 像素分辨率，当然这一看就是`高`x`宽`，咱们给它倒过来变成`宽`x`高`：1125 x 2436 ，可远远比你说的那个什么 375 x 812 高多了！

同学们如果有这样的疑虑的话，请按下你键盘上的 `f12` 键打开控制台(*苹果电脑是`⌘`+`⌥`+ `i`*)：
![图片描述](http://img.mukewang.com/wiki/5f636b3809a8fc4a12100348.jpg)
按下这个键，网页就会变成手机的格式，然后点击上面类似下拉菜单的这么一个东西：
![图片描述](http://img.mukewang.com/wiki/5f636bf7099694de08240730.jpg)
这里可以选择市面上主流的一些手机型号，大家可以看看分辨率都是多少：
![图片描述](http://img.mukewang.com/wiki/5f636c7c087b86bc07500182.jpg)

那这就奇怪了，这上面所有手机分辨率都很低，可以肯定的是现在的手机根本没有这么低的分辨率，那这到底是怎么一回事呢？答案要从很久很久以前说起：

在移动互联网刚刚兴起的时候，比较主流的智能手机是诺基亚塞班系统的类似于这种的3.2英寸的手机：

如果你还对这种手机有印象的话，那么恭喜你?，你已经老了。

这种手机是当时最实惠好用的智能手机，超大屏幕(*3.2寸*)，当然多少也是有点毛病的，比如不支持多点触控，必须使劲用指甲按屏幕才能有反应(*电阻屏*)，偶尔还会死机等…

直到后来 iPhone 4 的出现，大家相信或多或少也听过 iPhone 4 当年到底有多火，火到当初不少新闻都在报道什么孩子攀比非要逼着父母给自己买 iPhone。

甚至有一小部分买了 iPhone 手机的用户在街上都不把手机放进口袋里，而是拿在手里时不时的就拿起来显示一下自己的"尊贵身份"。

最夸张的一则新闻是有个年轻人为了得到 iPhone 不惜卖掉自己的一个肾(*这是真事*)：
![图片描述](http://img.mukewang.com/wiki/5f69c08508418ac706400434.jpg)
iPhone 4 能一下子这么火是有原因的，大家也知道苹果公司的操作系统用起来非常的顺滑，而且屏幕色彩也是非常的靓丽，最重要的是它的屏幕是世界上第一个视网膜屏，视网膜屏指的就是不仔细看压根儿就看不出屏幕上的像素点，而同时期的其他智能手机(*当时智能手机不仅仅有塞班，安卓在那个时候也已经开始崛起了*)，但没有哪一款手机可以拥有这么大的分辨率，即使屏幕大小都差不多，比如诺基亚的3.2寸和苹果的3.5寸，虽然尺寸相差并不是特别大，但诺基亚的颗粒感明显。

当时我还记得我买了一款号称全世界屏幕最大、最薄的手机：索爱LT15i；
当时它的屏幕尺寸为4.2寸，足足比 iPhone 4 的3.5寸大了一圈，我希望能用它的超大屏幕来掩盖住班里同学 iPhone 的光芒(*当时我也有点攀比，别学我哈*)，但当我拿到手机后，虽然屏幕尺寸很令人惊艳，但还是有着肉眼可见的颗粒感，细腻程度还是不如 iPhone 4 。

导致这个问题的最主要原因就是每英寸的分辨率(*DPI*)，来对比一下当年的这三款手机:

| 型号        | 分辨率    | DPI  |
| :---------- | :-------- | :--- |
| iPhone 4    | 960 × 640 | 326  |
| 诺基亚 5800 | 640 x 360 | 229  |
| 索爱 LT15i  | 854 x 480 | 233  |

> 乔布斯：人眼能分辨出的最大分辨率是300dpi，超过这个分辨率，人的眼睛就难以看出颗粒感

所以这就是视网膜屏幕的由来，可以看到在当时没有哪个手机的DPI能比得过 iPhone 4 ，当然咱们说这些并不是为了一顿狂吹 iPhone 4 的屏幕有多好，而是为了引出一个历史遗留问题：逻辑像素。



## 4. 逻辑像素

当时移动互联网已经悄然兴起，伴随着塞班的陨落，安卓和IOS正在强势崛起，所以很多网站需要适配手机的分辨率，但 iPhone 遥遥领先于众多竞争对手的分辨率就会带来这样一个问题：

假如我在页面里写了一个300像素(*px*)的按钮，在还没被淘汰的诺基亚手机上差不多占了83%的屏幕宽度，在超大屏幕的安卓手机上差不多要占据62%的屏幕宽度，而在视网膜屏幕的 iPhone 手机上居然只占了还不到一半的屏幕宽度！

![图片描述](http://img.mukewang.com/wiki/5f6469f90933f73a03180568.jpg)
假如在安卓或者诺基亚上显示成上面那样，那么在 iPhone 中300px的按钮就会显示成下面这样：
![图片描述](http://img.mukewang.com/wiki/5f646a8009d8593003200568.jpg)
这样太费眼睛了，iPhone 用户浏览网页难道还要拿着放大镜去看吗？那视网膜屏幕还有什么意义呢？

> 于是乎，逻辑像素这个概念出现了！

iPhone 4 的物理像素为 960 x 640，不知为何手机厂商宣传的时候总喜欢用`高` x `宽`，可能是因为`高`的数字大一些，放在前面好看？咱们给改成`宽` x `高`：640 x 960，那么它的逻辑像素就是 320 x 480，逻辑像素是什么呢？就是你写CSS的时候写的那个px。

在电脑端通常1px对应的就是屏幕的一个物理像素点，但手机之间的差异过大，为了抹平这个差异，高分辨率手机1px对应的就是两个物理像素点，低像素手机1px还是对应1个物理像素点，这样就不会出现同样 300px 的按钮，一个占了屏幕90%，另一个只占了一半的情况了。

现在的手机分辨率更加的夸张，所以 iPhone X 的1px对应的是三个物理像素点：
![图片描述](http://img.mukewang.com/wiki/5f636c7c087b86bc07500182.jpg)
这回再来看一下，375 x 812 的三倍是不是恰好就是 iPhone X 的真正像素 1125 x 2436 了呢？

虽然当年 iPhone 和安卓的分辨率差距很大，但经过多年的发展，如今的安卓屏幕也不至于比 iPhone 差那么多了，那么这种逻辑像素还有它存在的意义吗？

其实还是有意义的，随着科技的发展手机屏幕的分辨率一飞冲天，但是电脑的分辨率貌似没有什么太大的变化。
比如在我刚上大学时，大一点的笔记本电脑是 1920 x 1080 的分辨率，小一点的是 1366 x 768。
结果我现在都毕业好几年了，虽然也出现了一些高分辨率的2K电脑，但主流情况依然是大一点的笔记本 1920 x 1080，小一点的 1366 x 768。

如果取消了逻辑像素，1px 对应的就是屏幕上的一个物理像素点的话，那么iPhone X 横过来就变成了 2436 x 1125 分辨率，比电脑的 1920 x 1080 分辨率还高，我们就没有办法根据像素来判断用户到底现在用的是手机设备还是电脑设备了，但是现在 iPhone X 的逻辑分辨率只有 375 x 812，这样就很好判断了。



## 5. 小结

本章中我们详细讲述了为何在程序中的 iPhone 分辨率和现实中的 iPhone 分辨率有很大的差别，同时引出了逻辑像素的这么一个概念。

并且我们还罗列了一些媒体查询的常用属性，那么下一小节我们就来详细的讲解一下如何用媒体属性和逻辑操作符进行结合来判断用户当前到底在使用何种设备。

# 逻辑操作符



## 1. 前言

上一节课我们已经知道了哪些属性可以分辨不同的屏幕设备，并且也知道了程序中的像素为何与手机中的像素不匹配的原因。

那么本小节我们将利用逻辑操作符来结合前两节课讲的那些内容一起试水响应式布局。



## 2. 逻辑操作符

那么什么是逻辑操作符呢？

逻辑操作符可用于联合构造复杂的媒体查询，您还可以通过用逗号分隔多个媒体查询，将它们组合为一个规则。

逻辑操作符分为以下四种

|          | 含义                                                         |
| :------- | :----------------------------------------------------------- |
| and      | 用于将多个媒体查询规则组合成单条媒体查询，当每个查询规则都为真时则该条媒体查询为真，它还用于将媒体功能与媒体类型结合在一起。 |
| not      | 用于否定媒体查询，如果不满足这个条件则返回true，否则返回false。 如果出现在以逗号分隔的查询列表中，它将仅否定应用了该查询的特定查询。 如果使用not运算符，则还必须指定媒体类型 |
| only     | 仅在整个查询匹配时才用于应用样式，并且对于防止较早的浏览器应用所选样式很有用。 当不使用only时，旧版本的浏览器会将screen and (max-width: 500px)简单地解释为screen，忽略查询的其余部分，并将其样式应用于所有屏幕。 如果使用only运算符，则还必须指定媒体类型。 |
| , (逗号) | 逗号用于将多个媒体查询合并为一个规则。 逗号分隔列表中的每个查询都与其他查询分开处理。 因此，如果列表中的任何查询为true，则整个media语句均返回true。 换句话说，列表的行为类似于逻辑或or运算符。 |



## 3. and

看完上面的表格还是有些懵对吧？来看一下语法你就明白到底是怎么回事了：

```css
@media screen {
	div {
		color: black;
	}
}
 
```

为了方便大家的学习，上面写了一种最简单的媒体查询规则，其中`@media`是固定写法，表示创建一个媒体查询，后面跟着的是一个媒体类型，还记得前几节我们学过的那些媒体类型吗？通常咱们只会用到`screen`这种屏幕类型，然后大括号里面就可以写CSS语句了，你平时怎么写CSS，在大括号里就怎么写，也就是说上面的那几行代码代表的含义是：

> 当用户使用屏幕设备浏览网页时，页面上的div元素内的字体颜色变为黑色

⚠️不过需要注意的是，`@media`里面同样需要遵守CSS权重规则，比如后面的覆盖前面的，标签选择器覆盖不了类选择权的样式，所以尽量把`@media`写在整个CSS文件的末尾。

看懂最简单的语法后，再来加点难度了，比如我们希望字体颜色在手机上是蓝色，但是在电脑上是绿色：

```css
div {
	color: green;
}
@media screen and (max-width: 450px) {
	div {
		color: blue;
	}
}
 
```

假设宽度低于450px的设备就是手机设备，`@media screen`已经声明了屏幕设备，但是如果再加入一条媒体属性(`max-width: 450px`)的话就需要用`and`这个逻辑操作符来进行连接，有的同学可能搞不太懂为什么`max-width`就是小于等于的意思呢？

为了便于理解，咱们把`max-width`换一个说法，换成`max-salary`，意思是最高工资，然后`min-width`换成`min-salary`最低工资，大家应该都听说过很多城市都有着最低工资的标准吧。

拿北京市举例，目前的最低工资标准为2200元，换句话说你的工资肯定是大于等于(≥)2200元的。用代码写出来就变成了：`min-salary: 2200`，其实就等同于`salary ≥ 2200`。如果你理解了最低工资，那么相信你就会理解`max-width`和`min-width`了。

然后再来看代码，咱们将默认样式定义在了最前面，然后把`@media`定义在了后面，为的就是在规则满足咱们写的条件时，后面的样式能够覆盖掉前面的。

`and`就相当于并且的意思，`@media screen and (max-width: 450px)`就可以理解为：当媒体是屏幕设备**并且**最大宽度为450px时执行后面的代码。



## 4. not

not这个单词很好理解，看名字就知道是否定的意思，比如我们把刚才的需求反过来，变成字体颜色在手机上是绿色，但是在电脑上是蓝色：

```css
div {
	color: green;
}
@media not screen and (max-width: 450px) {
	div {
		color: blue;
	}
}
 
```

这么写看起来不是很好理解对吧，因为翻译成中文就是：`不是屏幕设备和最大宽度450`，看起来像是不在屏幕设备上生效一样，而实际上not不是仅仅否定跟在它后面的那个单词，而是否定整条语句，相当于：`@media not (screen and (max-width: 450px))`，这回再翻译成中文：`不是(最大宽度为450的屏幕设备)`，那么超过450px的宽度就已经符合这个条件了。



## 5. only

only从字面意思去理解是仅仅的意思，那么如果加入它以后：

```css
@media only screen {
	/* 省略若干代码 */
}
 
```

翻译成中文是：仅仅只在屏幕设备中生效。

可是咱们之前学的：

```css
@media screen {
	/* 省略若干代码 */
}
 
```

不也是只在屏幕设备上生效嘛，那加上这个only又有什么用呢？

实际上这是为了兼容低级浏览器而生的，它是为了在不支持媒体查询的浏览器中隐藏样式表，浏览器处理以only开头的关键词时将会忽略only。

这又是什么意思呢？其实就是在现代浏览器中，你加不加only效果都是一样的。
但在一些非常老旧的浏览器，如果你加了only，它就会直接忽略掉这条语句。

看到这你可能不明白了，为什么要让老版本浏览器忽略掉你写的@media呢？

你可以简单的理解为：老版本浏览器有点近视眼，只看得到@media和紧跟在它后面的一个单词。
在它的眼中，你写的`@media only screen and (max-width: 450px)`它只看得到`@media only`。
如果你还记得媒体设备的那张表格的话，你应该知道压根儿就没有only这种设备，所以它就会认为你写错了，从而忽略掉这段语句。

但是如果你不加only的话，那么你写的`@media screen and (max-width: 450px)`在它眼里就会看成`@media screen`，因为没有看到后面的限制条件，所以你写在@media里面的CSS代码会在 screen 这种设备生效，就相当于在所有屏幕设备(*手机、平板、笔记本*)这段代码都会生效。



## 6. 逗号

逗号其实就相当于`或者`的意思，其实我发现有一小部分人有点搞不清`并且`和`或者`的区别。这在日常生活中影响可能不大，但是在程序中如果你不能理解`并且`和`或者`的话可能会导致你的代码出bug。

举个例子，如果想表示一个数(*x*)大于10、小于0，应该怎么写？会不会写成这样：
`10 < x < 0`
但其实这么写虽然能看懂，但语法是错的，想让计算机认识你写的代码的话应该写成这样：
`x < 0 (或/并) x > 10`
你觉得，应该是`或`还是`并`呢？

> 正确答案是**或**

如果是**并**的话，需要同时满足这两个条件，试问什么数能够既小于0又大于10 呢？

只能尽量的满足这俩条件中的一个，这就叫作`或`。就相当于一个人，你不能让他既高又矮、既胖又瘦吧。

理解了`或`，那么咱们就可以用逗号来写代码了：

```css
div {
	color: green;
}
@media screen and (max-width: 450px), (min-width: 1200px) {
	div {
		color: blue;
	}
}
 
```

这回的意思是：字体在平板设备(*假设平板设备宽度在450和1200之间*)上是绿色，其他设备是蓝色。
这就相当于：`x ≤ 450 或 x ≥ 1200`，x 就是其他设备。

当然了，其实如果把 x 当成平板设备的话会更合理：
`x ≥ 450 并 x ≤ 1200` (450 ≤ x ≤ 1200)

```css
div {
	color: blue;
}
@media screen and (min-width: 450px) and (max-width: 1200px) {
	div {
		color: green;
	}
}
 
```

但是咱们之前之所以把平板写成那样是为了给大家演示逗号的写法，大家可以根据自己的业务逻辑来灵活的选择用`并`(*and*)还是`或`(*,*)。



## 7. 思考

为什么要用这么最大宽度(*max-width*)、最小宽度(*min-width*)累赘的写法呢？
直接用数学符号大于(>)小于(<)多好啊！既直观，又方便。

其实原因是因为，在 HTML 中，大于号(>)小于号(<)是标签的组成部分，假如你是在 <style> 标签内部写的@media：

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>media</title>
  <style>
    @media screen and (450px < width < 1200px) {
    }
  </style>
</head>
<body>
</body>
</html>
 
```

解析器可能会搞混各种标签，不知道你是要写标签还是只是一个小于号(*还是不够智能啊*)。

不过鉴于这种语法既直观又方便，CSS4打算将其纳入标准，但目前还不是使用这种语法的时候。



## 8. 简写

有时你看别的教程或者别人的代码可能会写成这样：

```css
@media (min-width: 450px) {
	/* 此处省略若干代码 */
}
 
```

可以看到`@media`的后面并没有写任何的媒体类型，而是直接写了一个媒体属性，而且这样的代码也可以生效，那么这是为什么呢？

还记得媒体设备的那张表格吗？

| 设备   | 中文含义                           |
| :----- | :--------------------------------- |
| all    | 所有设备                           |
| print  | 用于打印机和打印预览               |
| screen | 用于电脑屏幕、平板电脑、智能手机等 |
| speech | 应用于屏幕阅读器等发声设备         |

如果你不写设备，默认就是 all，all 里面当然也包含了 screen 啦，上面的代码就相当于：

```css
@media all and (min-width: 450px) {
	/* 此处省略若干代码 */
}
 
```

如果你不是很关心网页在打印设备和发声设备上会是什么样的话，也可以省略媒体类型，反正大部分网页都是要显示在屏幕设备上的。



## 9. 结束语

看到这里，这门课就算是要结束了，如果你之前没有过移动端网页布局的经验，希望这门课可以帮到你。

不过有的同学可能会有疑惑，同样一个布局你居然写出那么多种实现方式，记不住啊！为什么不只写一种呢？

一方面是有些企业面试就喜欢面试者能够提供各种各样的不同解决方案，以此来考察面试者的技术是否足够全面。

所以我希望这门课可以帮助大家在面试过程中能够脱颖而出，让面试官觉得你的技术相当全面。

另一方面是有时候我们会遇到一些复杂样式的需求，不是咱们课程中的这几种很典型的布局。那么此时就需要你灵活运用各种 CSS 技术来实现复杂布局，可能这个按钮用个左浮动、那个图片用个绝对定位、Window10 菜单样式用个 Grid、外层容器用个 Flex 等：
![图片描述](http://img.mukewang.com/wiki/5f69ce170968bf4605940374.jpg)
只有能够灵活运用各种各样不同的 CSS 技术才能实现层出不穷的样式需求，只掌握一种方法还是远远不够的。

如果你实在学不动这么多种实现方式，那我建议你把每个章节中的弹性盒子法(*Flex*)重点练会即可，弹性盒子在移动端布局相当流行，并且功能也十分强大。